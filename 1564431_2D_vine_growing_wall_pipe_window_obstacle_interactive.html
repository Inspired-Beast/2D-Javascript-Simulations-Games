<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Realistic Vine Growth Simulation (ESM)</title>
  <style>
    body { margin:0; overflow:hidden; background:#eaf4ea; font-family:sans-serif; }
    #canvas-container { position:relative; width:100vw; height:100vh; }
    .ui {
      position:absolute;top:14px;left:14px;z-index:9;
      padding:14px 18px;border-radius:10px;background:#ffffffdd;
      box-shadow:0 4px 14px #0001;font-size:14px
    }
    .ui h3{margin:0 0 6px 0;font-size:15px;color:#2e5b2e}
    .ui button{
      padding:6px 14px;border:none;border-radius:6px;
      background:#4a7c59;color:#fff;cursor:pointer;font-size:13px
    }
    .ui button:hover{background:#5c8c69}
  </style>
  <script type="importmap">
    {
      "imports": {
        "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.19.0/+esm"
      }
    }
  </script>
</head>
<body>
<div class="ui">
  <h3>ðŸŒ± Realistic Vine Growth</h3>
  <button id="reset-btn">ðŸ”„ Reset</button><br>
  <small>
    â€¢ Single click to add pipe<br>
    â€¢ Double click to add window<br>
    â€¢ Drag obstacles to reposition<br>
  </small>
</div>
<div id="canvas-container"></div>
<script type="module">
import p5 from "p5";
import * as CANNON from "cannon-es";

// --- Parameters ---
const WALL_X = 0.5;
const WALL_W = 220;
const SEG_LEN = 5;
const SEG_RAD = 2;
const GROW_INTERVAL = 70;
const BASE_BRANCH_CHANCE = 0.05;
const TOP_BRANCH_CHANCE = 0.01;
const OBSTACLE_MARGIN = 8;
const MIN_BRANCH_DIST = 10;
const MAX_BRANCH_DEPTH = 4;
const PIPE_ARC_LIMIT = 15;
const LOOKAHEAD_REDUCTION = 0.9;
const MAX_SEGMENTS = 5000;
const GRAVITY = 0.015;
const DIRECTIONAL_BIAS = 0.12;
const NOISE_SCALE = 0.01;
const NOISE_STRENGTH = 0.15;
const LEAF_DENSITY = 0.4;

const sketch = (p) => {
  let world;
  let obstacles = [];
  let shoots = [];
  let dragging = null, dragDX = 0, dragDY = 0;
  let lastGrow = 0;
  let lastClickTime = 0;
  let clickTimeout = null;
  let wallGraphic;

  const WALL_LEFT = () => p.width*WALL_X - WALL_W/2;
  const WALL_RIGHT = () => p.width*WALL_X + WALL_W/2;

  function initPhysics() {
    if (world) {
      world.bodies.forEach(body => world.removeBody(body));
    }
    world = new CANNON.World({gravity: new CANNON.Vec3(0,0,0)});
  }

  class WindowOb {
    constructor(x, y, w=70, h=50) { this.x=x; this.y=y; this.w=w; this.h=h; this.type='window'; }
    contains(px, py) {
      return px > this.x-this.w/2-OBSTACLE_MARGIN && px < this.x+this.w/2+OBSTACLE_MARGIN &&
             py > this.y-this.h/2-OBSTACLE_MARGIN && py < this.y+this.h/2+OBSTACLE_MARGIN;
    }
    nearestEdge(px) {
      let left = this.x-this.w/2-OBSTACLE_MARGIN, right = this.x+this.w/2+OBSTACLE_MARGIN;
      return (Math.abs(px-left) < Math.abs(px-right)) ? left : right;
    }
    getPerimeterPoint(px, py) {
      let left = this.x-this.w/2-OBSTACLE_MARGIN;
      let right = this.x+this.w/2+OBSTACLE_MARGIN;
      let top = this.y-this.h/2-OBSTACLE_MARGIN;
      let bottom = this.y+this.h/2+OBSTACLE_MARGIN;
      let distToLeft = Math.abs(px - left);
      let distToRight = Math.abs(px - right);
      let distToTop = Math.abs(py - top);
      let distToBottom = Math.abs(py - bottom);
      let minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
      if (minDist === distToLeft) return {x: left, y: py};
      if (minDist === distToRight) return {x: right, y: py};
      if (minDist === distToTop) return {x: px, y: top};
      return {x: px, y: bottom};
    }
  }

  class PipeOb {
    constructor(x, y, r=25) { 
      this.x=x; 
      this.y=y; 
      this.r=r; 
      this.type='pipe';
      this.seed = p.random(10000);
    }
    contains(px, py) {
      return p.dist(px, py, this.x, this.y) < this.r+OBSTACLE_MARGIN;
    }
    getPerimeterPoint(px, py) {
      let angle = p.atan2(py - this.y, px - this.x);
      let perimeterX = this.x + p.cos(angle) * (this.r + OBSTACLE_MARGIN);
      let perimeterY = this.y + p.sin(angle) * (this.r + OBSTACLE_MARGIN);
      return {x: perimeterX, y: perimeterY};
    }
  }

  class Segment {
    constructor(x, y, branch, segmentIndex) {
      this.pos = p.createVector(x, y);
      this.branch = branch;
      this.segmentIndex = segmentIndex;
      this.hasLeaf = this.shouldHaveLeaf();
      this.leafAngle = p.random(-p.PI/2, p.PI/2);
      this.leafSize = p.random(0.9, 1.4) * (1.3 - 0.2 * branch.depth);
      this.leafType = p.random() < 0.7 ? 'normal' : 'small';
    }
    shouldHaveLeaf() {
      if (this.segmentIndex < 3) return false;
      let depthFactor = 1.2 - 0.25 * this.branch.depth;
      let heightFactor = p.map(this.pos.y, p.height, 0, 0.8, 1.2);
      let probability = depthFactor * heightFactor * LEAF_DENSITY;
      let interval = this.branch.depth === 0 ? 4 : (this.branch.depth === 1 ? 5 : 7);
      return (this.segmentIndex % interval === 0 && p.random() < probability) ||
             (p.random() < probability * 0.3);
    }
  }

  class Shoot {
    constructor(x, y, dir, depth=0, parent=null) {
      this.segs = [];
      this.dir = dir.copy().normalize();
      this.depth = depth;
      this.growing = true;
      this.state = 'normal';
      this.targetOb = null;
      this.edgeX = null;
      this.lastBranchAt = 0;
      this.segmentCount = 0;
      this.pipeArcSteps = 0;
      this.noiseSeed = p.random(10000);
      this.segs.push(new Segment(x, y, this, this.segmentCount++));
    }
    tip() { return this.segs[this.segs.length-1]; }
    stepGrowth() {
      if (!this.growing) return;
      let totalSegments = shoots.reduce((sum, shoot) => sum + shoot.segs.length, 0);
      if (totalSegments > MAX_SEGMENTS) {
        this.growing = false;
        return;
      }
      let t = this.tip();
      let pos = t.pos.copy();
      let dir = this.dir.copy();
      let next = null;
      // --- Following window perimeter ---
      if (this.state === 'followingWindow' && this.targetOb) {
        let left = this.targetOb.x-this.targetOb.w/2-OBSTACLE_MARGIN;
        let right = this.targetOb.x+this.targetOb.w/2+OBSTACLE_MARGIN;
        let top = this.targetOb.y-this.targetOb.h/2-OBSTACLE_MARGIN;
        let bottom = this.targetOb.y+this.targetOb.h/2+OBSTACLE_MARGIN;
        if (Math.abs(pos.x - left) < 3) {
          if (pos.y > top) next = p.createVector(left, pos.y - SEG_LEN);
          else next = p.createVector(pos.x + SEG_LEN, top);
        } else if (Math.abs(pos.x - right) < 3) {
          if (pos.y > top) next = p.createVector(right, pos.y - SEG_LEN);
          else next = p.createVector(pos.x - SEG_LEN, top);
        } else if (Math.abs(pos.y - top) < 3) {
          if (this.edgeX === left) {
            next = p.createVector(pos.x + SEG_LEN, top);
            if (pos.x >= this.targetOb.x) {
              this.state = 'normal';
              this.targetOb = null;
              this.dir = p.createVector(0, -1);
            }
          } else {
            next = p.createVector(pos.x - SEG_LEN, top);
            if (pos.x <= this.targetOb.x) {
              this.state = 'normal';
              this.targetOb = null;
              this.dir = p.createVector(0, -1);
            }
          }
        } else {
          let perimPoint = this.targetOb.getPerimeterPoint(pos.x, pos.y);
          next = p.createVector(perimPoint.x, perimPoint.y);
        }
      }
      // --- Following pipe perimeter ---
      else if (this.state === 'followingPipe' && this.targetOb) {
        let angle = p.atan2(pos.y - this.targetOb.y, pos.x - this.targetOb.x);
        angle -= 0.15 - p.random(0.03);
        let radius = this.targetOb.r + OBSTACLE_MARGIN;
        let nx = this.targetOb.x + p.cos(angle) * radius;
        let ny = this.targetOb.y + p.sin(angle) * radius - 0.8;
        next = p.createVector(nx, ny);
        this.pipeArcSteps = (this.pipeArcSteps || 0) + 1;
        if (ny < this.targetOb.y - radius - 5 || this.pipeArcSteps > PIPE_ARC_LIMIT) {
          this.state = 'normal';
          this.targetOb = null;
          this.dir = p.createVector(0, -1);
          this.pipeArcSteps = 0;
        }
      }
      // --- Normal growth with smooth Perlin noise ---
      else {
        let lookahead = pos.copy().add(dir.copy().mult(SEG_LEN*1.5*LOOKAHEAD_REDUCTION));
        let found = false;
        for (let ob of obstacles) {
          if (ob.contains(lookahead.x, lookahead.y)) {
            found = true;
            if (ob.type === 'window') {
              this.state = 'followingWindow';
              this.targetOb = ob;
              this.edgeX = ob.nearestEdge(pos.x);
              let perimPoint = ob.getPerimeterPoint(pos.x, pos.y);
              next = p.createVector(perimPoint.x, perimPoint.y);
              break;
            } else if (ob.type === 'pipe') {
              this.state = 'followingPipe';
              this.targetOb = ob;
              let perimPoint = ob.getPerimeterPoint(pos.x, pos.y);
              next = p.createVector(perimPoint.x, perimPoint.y);
              this.pipeArcSteps = 0;
              break;
            }
          }
        }
        if (!found) {
          let noiseVal = p.noise(this.noiseSeed, this.segs.length * NOISE_SCALE);
          let angle = p.map(noiseVal, 0, 1, -NOISE_STRENGTH, NOISE_STRENGTH);
          dir.rotate(angle);
          dir.y += GRAVITY;
          dir.y -= DIRECTIONAL_BIAS;
          dir.normalize();
          let segmentLength = SEG_LEN + p.random(-0.5, 0.8);
          let nx = p.constrain(pos.x + dir.x*segmentLength, WALL_LEFT()+SEG_RAD, WALL_RIGHT()-SEG_RAD);
          let ny = pos.y + dir.y*segmentLength;
          next = p.createVector(nx, ny);
          this.dir = p.createVector(nx-pos.x, ny-pos.y).normalize();
        }
      }
      if (next) {
        this.segs.push(new Segment(next.x, next.y, this, this.segmentCount++));
        if (next.y < 30) this.growing = false;
      }
      if (
        this.depth < MAX_BRANCH_DEPTH &&
        this.segs.length > 8 &&
        this.segs.length - this.lastBranchAt > MIN_BRANCH_DIST &&
        totalSegments < MAX_SEGMENTS * 0.8
      ) {
        let y = this.tip().pos.y;
        let branchChance = p.map(y, p.height, 0, BASE_BRANCH_CHANCE, TOP_BRANCH_CHANCE, true);
        if (this.depth <= 1) branchChance *= 1.8;
        if (p.random() < branchChance) {
          let angle = p.random(-p.PI/2.8, p.PI/2.8);
          let upwardness = p.map(y, p.height, 0, 0.4, 0.85, true);
          let branchDir = p5.Vector.lerp(
            this.dir.copy().rotate(angle),
            p.createVector(0, -1),
            upwardness
          );
          shoots.push(new Shoot(this.tip().pos.x, this.tip().pos.y, branchDir, this.depth+1, this));
          this.lastBranchAt = this.segs.length;
        }
      }
    }
  }

  function drawWallToBuffer() {
    wallGraphic.background(235, 225, 210);
    wallGraphic.noStroke();
    wallGraphic.rect(0, 0, WALL_W, p.height);
    wallGraphic.stroke(200, 185, 165);
    wallGraphic.strokeWeight(2);
    let brickW = 45, brickH = 20;
    for (let y = 0; y < p.height; y += brickH) {
      for (let x = 0; x < WALL_W; x += brickW) {
        let offsetX = (Math.floor(y / brickH) % 2) * (brickW / 2);
        wallGraphic.fill(p.random(220, 240), p.random(200, 220), p.random(180, 200));
        wallGraphic.rect(x + offsetX, y, brickW - 2, brickH - 2, 2);
      }
    }
    for (let i = 0; i < 50; i++) {
      wallGraphic.fill(0, 0, 0, p.random(5, 15));
      wallGraphic.noStroke();
      let x = p.random(0, WALL_W);
      let y = p.random(0, p.height);
      wallGraphic.ellipse(x, y, p.random(1, 3));
    }
  }

  function drawObstacles() {
    obstacles.forEach(ob => {
      if (ob.type === 'window') {
        p.fill(120, 100, 80);
        p.stroke(80, 60, 40);
        p.strokeWeight(4);
        p.rect(ob.x-ob.w/2-5, ob.y-ob.h/2-5, ob.w+10, ob.h+10, 6);
        p.fill(180, 200, 230, 200);
        p.stroke(140, 160, 190);
        p.strokeWeight(2);
        p.rect(ob.x-ob.w/2, ob.y-ob.h/2, ob.w, ob.h, 4);
        p.fill(255, 255, 255, 80);
        p.noStroke();
        p.rect(ob.x-ob.w/2+5, ob.y-ob.h/2+5, ob.w/3, ob.h/2, 2);
        p.stroke(100, 80, 60);
        p.strokeWeight(3);
        p.line(ob.x, ob.y-ob.h/2, ob.x, ob.y+ob.h/2);
        p.line(ob.x-ob.w/2, ob.y, ob.x+ob.w/2, ob.y);
      } else {
        p.randomSeed(ob.seed);
        p.fill(0, 0, 0, 30);
        p.noStroke();
        p.ellipse(ob.x+4, ob.y+4, ob.r*2.3);
        p.fill(140, 140, 140);
        p.stroke(100, 100, 100);
        p.strokeWeight(3);
        p.ellipse(ob.x, ob.y, ob.r*2);
        p.fill(30, 30, 30);
        p.noStroke();
        p.ellipse(ob.x, ob.y, ob.r*1.4);
        p.fill(80, 80, 80);
        p.noStroke();
        p.ellipse(ob.x, ob.y, ob.r*1.2);
        p.fill(15, 15, 15);
        p.noStroke();
        p.ellipse(ob.x, ob.y, ob.r*0.9);
        p.fill(180, 180, 180);
        p.noStroke();
        p.ellipse(ob.x-ob.r/3, ob.y-ob.r/3, ob.r*1.2);
        p.stroke(80, 80, 80);
        p.strokeWeight(2);
        p.noFill();
        p.ellipse(ob.x, ob.y, ob.r*1.8);
        p.ellipse(ob.x, ob.y, ob.r*1.6);
        p.stroke(60, 60, 60);
        p.strokeWeight(1);
        p.noFill();
        p.ellipse(ob.x, ob.y, ob.r*1.1);
        for (let i = 0; i < 4; i++) {
          p.fill(160, 100, 60, 120);
          p.noStroke();
          let angle = p.random(p.TWO_PI);
          let dist = p.random(ob.r*0.4, ob.r*0.8);
          let px = ob.x + p.cos(angle) * dist;
          let py = ob.y + p.sin(angle) * dist;
          p.ellipse(px, py, p.random(2, 5));
        }
        p.stroke(120, 120, 120, 100);
        p.strokeWeight(1);
        for (let i = 0; i < 3; i++) {
          let angle = p.random(p.TWO_PI);
          let startDist = ob.r * 0.6;
          let endDist = ob.r * 0.9;
          let x1 = ob.x + p.cos(angle) * startDist;
          let y1 = ob.y + p.sin(angle) * startDist;
          let x2 = ob.x + p.cos(angle) * endDist;
          let y2 = ob.y + p.sin(angle) * endDist;
          p.line(x1, y1, x2, y2);
        }
        p.randomSeed();
      }
    });
  }

  function drawVines() {
    shoots.forEach(branch => {
      let greenBase = 45 + branch.depth * 15;
      let greenVariation = 120 + 25 * branch.depth;
      p.stroke(greenBase, greenVariation, 60 + branch.depth * 10);
      p.strokeWeight(SEG_RAD * (2.8 - branch.depth * 0.6));
      p.noFill();
      p.beginShape();
      if (branch.segs.length > 2) {
        p.curveVertex(branch.segs[0].pos.x, branch.segs[0].pos.y);
      }
      for (let seg of branch.segs) {
        p.curveVertex(seg.pos.x, seg.pos.y);
      }
      if (branch.segs.length > 2) {
        let last = branch.segs[branch.segs.length-1];
        p.curveVertex(last.pos.x, last.pos.y);
      }
      p.endShape();
      branch.segs.forEach(seg => {
        if (seg.hasLeaf) {
          drawLeaf(seg.pos.x, seg.pos.y, seg.leafAngle, seg.leafSize, seg.leafType, branch.depth);
        }
      });
      if (branch.growing) {
        let tip = branch.tip().pos;
        p.noStroke();
        p.fill(70, 200, 90, 150);
        p.ellipse(tip.x, tip.y, SEG_RAD*3);
        p.fill(90, 255, 110, 100);
        p.ellipse(tip.x, tip.y, SEG_RAD*2);
      }
    });
  }

  function drawLeaf(x, y, angle, size, type, depth) {
    p.push();
    p.translate(x, y);
    p.rotate(angle);
    p.scale(size);
    let alpha = 200 - depth * 30;
    let leafGreen = 50 + depth * 20;
    if (type === 'small') {
      p.fill(leafGreen, 160, 70, alpha);
      p.noStroke();
      p.ellipse(8, 0, 12, 6);
      p.ellipse(-8, 0, 12, 6);
    } else {
      p.fill(leafGreen, 150, 70, alpha);
      p.noStroke();
      p.ellipse(15, -3, 18, 12);
      p.ellipse(-15, 3, 18, 12);
      p.ellipse(0, -8, 14, 8);
      p.ellipse(0, 8, 14, 8);
      p.stroke(leafGreen - 20, 120, 50, alpha * 0.8);
      p.strokeWeight(0.8);
      p.line(-12, 0, 12, 0);
      p.line(0, -6, 0, 6);
      p.line(-8, -3, 8, 3);
    }
    p.pop();
  }

  p.setup = () => {
    const canvas = p.createCanvas(window.innerWidth, window.innerHeight);
    canvas.parent('canvas-container');
    p.pixelDensity(1);
    p.frameRate(30);
    wallGraphic = p.createGraphics(WALL_W, p.height);
    drawWallToBuffer();
    resetSim();
    document.getElementById('reset-btn').onclick = resetSim;
  };

  p.windowResized = () => {
    p.resizeCanvas(window.innerWidth, window.innerHeight);
    wallGraphic = p.createGraphics(WALL_W, p.height);
    drawWallToBuffer();
  };

  p.draw = () => {
    p.background(245, 250, 245);
    p.image(wallGraphic, WALL_LEFT(), 0);
    if (p.millis() - lastGrow > GROW_INTERVAL) {
      shoots.forEach(b => b.stepGrowth());
      lastGrow = p.millis();
    }
    drawObstacles();
    drawVines();
    p.fill(0);
    p.textSize(12);
    let totalSegs = shoots.reduce((sum, shoot) => sum + shoot.segs.length, 0);
    p.text(`Segments: ${totalSegs}/${MAX_SEGMENTS}`, p.width - 150, 20);
  };

  p.mousePressed = () => {
    for (const ob of obstacles) {
      if (ob.type === 'window' && ob.contains(p.mouseX, p.mouseY)) {
        dragging = ob; dragDX = ob.x - p.mouseX; dragDY = ob.y - p.mouseY; return;
      }
      if (ob.type === 'pipe' && p.dist(p.mouseX, p.mouseY, ob.x, ob.y) < ob.r+10) {
        dragging = ob; dragDX = ob.x - p.mouseX; dragDY = ob.y - p.mouseY; return;
      }
    }
    let currentTime = p.millis();
    if (currentTime - lastClickTime < 300) {
      if (clickTimeout) {
        clearTimeout(clickTimeout);
        clickTimeout = null;
      }
      let x = p.constrain(p.mouseX, WALL_LEFT()+40, WALL_RIGHT()-40);
      obstacles.push(new WindowOb(x, p.mouseY));
    } else {
      clickTimeout = setTimeout(() => {
        let x = p.constrain(p.mouseX, WALL_LEFT()+30, WALL_RIGHT()-30);
        obstacles.push(new PipeOb(x, p.mouseY));
        clickTimeout = null;
      }, 300);
    }
    lastClickTime = currentTime;
  };

  p.mouseDragged = () => {
    if (dragging) {
      dragging.x = p.constrain(p.mouseX + dragDX, WALL_LEFT()+40, WALL_RIGHT()-40);
      dragging.y = p.constrain(p.mouseY + dragDY, 60, p.height - 60);
    }
  };

  p.mouseReleased = () => { dragging = null; };

  function resetSim() {
    initPhysics();
    let cx = p.width*WALL_X;
    obstacles = [
      new WindowOb(cx+60, p.height/2-120, 80, 55),
      new PipeOb(cx-40, p.height/2-200, 28),
      new WindowOb(cx+80, p.height/2-280, 70, 50)
    ];
    shoots = [];
    let baseY = p.height-60;
    shoots.push(new Shoot(cx, baseY, p.createVector(0, -1), 0));
    shoots.push(new Shoot(cx-15, baseY, p.createVector(-0.15, -0.99), 1));
    shoots.push(new Shoot(cx+15, baseY, p.createVector(0.15, -0.99), 1));
    shoots.push(new Shoot(cx-8, baseY, p.createVector(-0.08, -0.997), 1));
    shoots.push(new Shoot(cx+8, baseY, p.createVector(0.08, -0.997), 1));
    lastGrow = p.millis();
  }
};

new p5(sketch, document.getElementById('canvas-container'));
</script>
</body>
</html>
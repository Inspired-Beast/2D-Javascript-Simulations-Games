<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Catapult Mini-Game</title>
    <script type="importmap">
    {
        "imports": {
            "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
        }
    }
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #eaeaea;
            font-family: Arial, sans-serif;
            color: #333;
            overflow: hidden;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
            border: 2px solid #8B4513;
        }
        .control-row {
            margin: 12px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .slider {
            width: 140px;
            height: 8px;
            border-radius: 5px;
            background: #8B4513;
            outline: none;
            -webkit-appearance: none;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #D2691E;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(210, 105, 30, 0.3);
        }
        .value {
            min-width: 60px;
            color: #D2691E;
            font-weight: bold;
            text-align: center;
        }
        button {
            padding: 12px 24px;
            margin: 8px 5px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #D2691E, #8B4513);
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(210, 105, 30, 0.2);
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 20px;
            border-radius: 15px;
            z-index: 100;
            text-align: center;
            border: 2px solid #8B4513;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.08);
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #D2691E;
            text-shadow: 0 0 20px rgba(210, 105, 30, 0.2);
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 200;
            pointer-events: none;
        }
        h3 {
            margin-top: 0;
            color: #D2691E;
            text-align: center;
        }
        label {
            min-width: 60px;
            font-size: 14px;
        }
        #gameCanvas {
            border: none;
        }
        .status {
            font-size: 16px;
            font-weight: bold;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>üèπ Catapult Simulator</h3>
        <div class="control-row">
            <label>Angle:</label>
            <input type="range" class="slider" id="angleSlider" min="15" max="75" value="45" />
            <span class="value" id="angleValue">45¬∞</span>
        </div>
        <div class="control-row">
            <label>Power:</label>
            <input type="range" class="slider" id="powerSlider" min="50" max="180" value="110" />
            <span class="value" id="powerValue">110%</span>
        </div>
        <button id="launchBtn">üöÄ LAUNCH</button>
        <button id="resetBtn">üîÑ RESET</button>
        <div class="status" id="statusDisplay">Ready to Launch</div>
    </div>
    <div id="stats">
        <h3>üìä Stats</h3>
        <div>Shots: <span id="shotCount">0</span></div>
        <div>Hits: <span id="hitCount">0</span></div>
        <div>Accuracy: <span id="accuracy">0%</span></div>
        <div>Best Streak: <span id="streak">0</span></div>
    </div>
    <div id="message"></div>
    <script type="module">
        import p5 from 'p5';

        new p5((p) => {
            // --- Constants ---
            const GRAVITY = 0.5;
            const AIR_RESISTANCE = 0.995;
            const PROJECTILE_SIZE = 18;
            const WALL_X_RATIO = 0.75; // 75% of canvas width
            const WALL_WIDTH = 60;
            const TARGET_GAP_HEIGHT = 60;
            const CANVAS_WIDTH = window.innerWidth;
            const CANVAS_HEIGHT = window.innerHeight;
            const FLOOR_Y = CANVAS_HEIGHT - 100;
            const BOARD_COLOR = p => p.color(220, 210, 180);
            const WOOD_COLOR = p => p.color(180, 140, 80);

            // --- Game variables ---
            let catapult;
            let projectile;
            let launched = false;
            let armAnimating = false;
            let armAnimAngle = 0;
            let armAnimStart = 0;
            let armAnimEnd = 0;
            let armAnimTime = 0;
            let armAnimDuration = 0.25; // seconds
            let trajectory = [];
            let gameStats = { shots: 0, hits: 0, streak: 0, bestStreak: 0 };
            let params = { angle: 45, power: 110 };
            let particles = [];

            // --- Wall/Target ---
            let wallX, gapY;

            // --- Randomize the target gap location ---
            function randomizeGapY() {
                // The gap should always be fully visible between the top and the floor
                const minY = 30;
                const maxY = FLOOR_Y - TARGET_GAP_HEIGHT - 30;
                gapY = Math.floor(Math.random() * (maxY - minY + 1)) + minY;
            }

            // --- Catapult class ---
            class Catapult {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.baseWidth = 60;
                    this.baseHeight = 40;
                    this.armLength = 70;
                    this.pivotOffsetY = 10;
                    this.ropeAnchor = { x: this.x - 30, y: this.y - 60 };
                }
                getInitialVelocity() {
                    const speed = (params.power / 100) * 38;
                    const radians = (params.angle * Math.PI) / 180;
                    return {
                        x: Math.cos(radians) * speed,
                        y: -Math.sin(radians) * speed
                    };
                }
                calculateTrajectory() {
                    const points = [];
                    const vel = this.getInitialVelocity();
                    let x = this.x + Math.cos(-params.angle * Math.PI / 180) * this.armLength;
                    let y = this.y - Math.sin(params.angle * Math.PI / 180) * this.armLength;
                    let vx = vel.x;
                    let vy = vel.y;
                    for (let i = 0; i < 400; i++) {
                        points.push({x: x, y: y});
                        x += vx;
                        y += vy;
                        vy += GRAVITY;
                        vx *= AIR_RESISTANCE;
                        vy *= AIR_RESISTANCE;
                        if (y >= FLOOR_Y || x >= wallX + WALL_WIDTH + 10) break;
                    }
                    return points;
                }
                display(armOverrideAngle = null) {
                    // Catapult base
                    p.push();
                    p.fill(101, 67, 33);
                    p.stroke(80, 50, 20);
                    p.strokeWeight(2);
                    p.rect(this.x - this.baseWidth/2, this.y, this.baseWidth, this.baseHeight, 8);
                    // Wheels
                    p.fill(80, 50, 20);
                    p.ellipse(this.x - 20, this.y + this.baseHeight + 10, 22, 22);
                    p.ellipse(this.x + 20, this.y + this.baseHeight + 10, 22, 22);
                    p.pop();

                    // Catapult frame
                    p.push();
                    p.stroke(120, 80, 40);
                    p.strokeWeight(8);
                    p.line(this.x - 25, this.y + 10, this.x - 25, this.y - 60);
                    p.line(this.x + 25, this.y + 10, this.x + 25, this.y - 60);
                    p.line(this.x - 25, this.y - 60, this.x + 25, this.y - 60);
                    p.pop();

                    // Rope (drawn taut from anchor to arm tip)
                    let armAngle = armOverrideAngle !== null ? armOverrideAngle : -params.angle * Math.PI / 180;
                    let armTipX = this.x + Math.cos(armAngle) * this.armLength;
                    let armTipY = this.y + Math.sin(armAngle) * this.armLength;
                    p.push();
                    p.stroke(180, 120, 60);
                    p.strokeWeight(4);
                    p.line(this.ropeAnchor.x, this.ropeAnchor.y, armTipX, armTipY);
                    p.pop();

                    // Rope anchor
                    p.push();
                    p.fill(120, 80, 40);
                    p.noStroke();
                    p.ellipse(this.ropeAnchor.x, this.ropeAnchor.y, 12, 12);
                    p.pop();

                    // Arm
                    p.push();
                    p.translate(this.x, this.y);
                    p.rotate(armAngle);
                    p.stroke(139, 69, 19);
                    p.strokeWeight(12);
                    p.line(0, 0, this.armLength, 0);
                    // Bucket
                    p.fill(160, 82, 45);
                    p.stroke(120, 60, 30);
                    p.strokeWeight(2);
                    p.arc(this.armLength, 0, 28, 20, 0, Math.PI);
                    p.pop();

                    // Tension arc (shows tension visually)
                    p.push();
                    p.noFill();
                    p.stroke(255, 0, 0, 80);
                    p.strokeWeight(3);
                    let tension = p.map(params.power, 50, 180, 0.2, 1.0);
                    let arcStart = -Math.PI/2 - tension * Math.PI/3;
                    let arcEnd = -Math.PI/2 + tension * Math.PI/3;
                    p.arc(this.x, this.y, 90, 90, arcStart, arcEnd);
                    p.pop();

                    // Projectile in bucket (if not launched)
                    if (!launched) {
                        p.push();
                        p.translate(armTipX, armTipY);
                        p.fill(139, 69, 19);
                        p.stroke(101, 67, 33);
                        p.strokeWeight(2);
                        p.ellipse(0, 0, PROJECTILE_SIZE);
                        p.fill(160, 82, 45);
                        p.noStroke();
                        p.ellipse(-2, -2, PROJECTILE_SIZE * 0.4);
                        p.pop();
                    }
                }
            }

            // --- Projectile class ---
            class Projectile {
                constructor(x, y, velocity) {
                    this.x = x;
                    this.y = y;
                    this.vx = velocity.x;
                    this.vy = velocity.y;
                    this.size = PROJECTILE_SIZE;
                    this.trail = [];
                    this.active = true;
                    this.hasHit = false;
                    this.bounceCount = 0;
                    this.angularVelocity = 0;
                    this.angle = 0;
                    this.mass = 1;
                }
                update() {
                    if (!this.active) return;
                    this.trail.push({x: this.x, y: this.y});
                    if (this.trail.length > 25) this.trail.shift();
                    this.x += this.vx;
                    this.y += this.vy;
                    this.angle += this.angularVelocity;
                    this.vy += GRAVITY;
                    this.vx *= AIR_RESISTANCE;
                    this.vy *= AIR_RESISTANCE;
                    // Floor bounce
                    if (this.y >= FLOOR_Y) {
                        this.y = FLOOR_Y;
                        let vNorm = this.vy;
                        let vTan = this.vx;
                        let e = 0.5;
                        let mu = 0.2;
                        this.vy = -e * vNorm;
                        this.vx = vTan * (1 - mu);
                        this.angularVelocity += vTan * 0.02;
                        this.bounceCount++;
                        if (Math.abs(this.vy) < 1 && Math.abs(this.vx) < 0.5) {
                            this.active = false;
                            if (!this.hasHit) {
                                updateStatus('Missed target!');
                                gameStats.streak = 0;
                            }
                        }
                    }
                    // Wall bounce
                    if (
                        this.x + this.size/2 >= wallX &&
                        this.x - this.size/2 <= wallX + WALL_WIDTH &&
                        (
                            this.y < gapY || this.y > gapY + TARGET_GAP_HEIGHT
                        )
                    ) {
                        if (this.vx > 0) {
                            this.x = wallX - this.size/2;
                            let vNorm = this.vx;
                            let vTan = this.vy;
                            let e = 0.6;
                            let mu = 0.15;
                            this.vx = -e * vNorm;
                            this.vy = vTan * (1 - mu);
                            this.angularVelocity += vTan * 0.02 + (Math.random()-0.5)*0.1;
                            this.bounceCount++;
                            this.createImpactParticles();
                            updateStatus('Bounced off wall!');
                        }
                    }
                    // Success: pass through gap
                    if (
                        !this.hasHit &&
                        this.x + this.size/2 >= wallX &&
                        this.x - this.size/2 <= wallX + WALL_WIDTH &&
                        this.y >= gapY &&
                        this.y <= gapY + TARGET_GAP_HEIGHT
                    ) {
                        this.hasHit = true;
                        gameStats.hits++;
                        gameStats.streak++;
                        if (gameStats.streak > gameStats.bestStreak) gameStats.bestStreak = gameStats.streak;
                        this.showSuccessMessage();
                        this.createSuccessParticles();
                        updateStatus('üéØ Target Hit! +10 points');
                        // Randomize the target gap after a successful hit
                        setTimeout(() => {
                            randomizeGapY();
                            calculateTrajectory();
                        }, 800);
                    }
                    // Out of bounds
                    if (this.x < 0 || this.x > CANVAS_WIDTH) {
                        this.active = false;
                        if (!this.hasHit) {
                            updateStatus('Out of bounds!');
                            gameStats.streak = 0;
                        }
                    }
                }
                showSuccessMessage() {
                    const messages = [
                        'BULLSEYE! üéØ',
                        'PERFECT SHOT! ‚≠ê',
                        'AMAZING! üî•',
                        'INCREDIBLE! ‚ú®',
                        'ON TARGET! üöÄ'
                    ];
                    const messageEl = document.getElementById('message');
                    messageEl.textContent = messages[Math.floor(Math.random() * messages.length)];
                    messageEl.style.opacity = '1';
                    setTimeout(() => { messageEl.style.opacity = '0'; }, 2500);
                }
                createSuccessParticles() {
                    for (let i = 0; i < 15; i++) {
                        particles.push({
                            x: this.x,
                            y: this.y,
                            vx: p.random(-3, 3),
                            vy: p.random(-5, -1),
                            life: 60,
                            color: p.color(255, 215, 0),
                            size: p.random(3, 8)
                        });
                    }
                }
                createImpactParticles() {
                    for (let i = 0; i < 10; i++) {
                        particles.push({
                            x: this.x,
                            y: this.y,
                            vx: p.random(-2, 2),
                            vy: p.random(-3, 1),
                            life: 40,
                            color: p.color(139, 69, 19),
                            size: p.random(2, 5)
                        });
                    }
                }
                display() {
                    for (let i = 0; i < this.trail.length; i++) {
                        const alpha = (i / this.trail.length) * 150;
                        p.fill(255, 100, 0, alpha);
                        p.noStroke();
                        const size = (i / this.trail.length) * this.size;
                        p.ellipse(this.trail[i].x, this.trail[i].y, size);
                    }
                    p.push();
                    p.translate(this.x, this.y);
                    p.rotate(this.angle);
                    p.fill(139, 69, 19);
                    p.stroke(101, 67, 33);
                    p.strokeWeight(2);
                    p.ellipse(0, 0, this.size);
                    p.fill(160, 82, 45);
                    p.noStroke();
                    p.ellipse(-2, -2, this.size * 0.4);
                    p.stroke(255, 255, 255, 120);
                    p.strokeWeight(2);
                    p.line(0, 0, this.size/2, 0);
                    p.pop();
                }
            }

            // --- Particle system ---
            function updateParticles() {
                for (let i = particles.length - 1; i >= 0; i--) {
                    let particle = particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.1;
                    particle.life--;
                    if (particle.life <= 0) particles.splice(i, 1);
                }
            }
            function drawParticles() {
                for (let particle of particles) {
                    let alpha = p.map(particle.life, 0, 60, 0, 255);
                    p.fill(p.red(particle.color), p.green(particle.color), p.blue(particle.color), alpha);
                    p.noStroke();
                    p.ellipse(particle.x, particle.y, particle.size);
                }
            }

            // --- p5.js main functions ---
            p.setup = function() {
                p.createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
                wallX = Math.floor(CANVAS_WIDTH * WALL_X_RATIO);
                randomizeGapY(); // Randomize the gap at the start
                catapult = new Catapult(80, FLOOR_Y - 40);
                calculateTrajectory();
                setupControls();
            };
            p.draw = function() {
                drawBoardEnvironment();
                drawTarget();
                if (!launched && !armAnimating) drawTrajectory();
                if (armAnimating) {
                    // Animate arm from cocked to release
                    let t = (p.millis() - armAnimTime) / (armAnimDuration * 1000);
                    if (t < 1) {
                        let angle = armAnimStart + (armAnimEnd - armAnimStart) * t;
                        catapult.display(angle);
                    } else {
                        armAnimating = false;
                        catapult.display(armAnimEnd);
                        // Launch projectile from arm tip
                        let armTipX = catapult.x + Math.cos(armAnimEnd) * catapult.armLength;
                        let armTipY = catapult.y + Math.sin(armAnimEnd) * catapult.armLength;
                        const velocity = catapult.getInitialVelocity();
                        projectile = new Projectile(armTipX, armTipY, velocity);
                        launched = true;
                        gameStats.shots++;
                        updateStatus('Projectile in flight...');
                        document.getElementById('launchBtn').disabled = true;
                    }
                } else {
                    catapult.display();
                }
                if (projectile && projectile.active) {
                    projectile.update();
                    projectile.display();
                }
                updateParticles();
                drawParticles();
                updateStatsDisplay();
            };

            // --- Board/Indoor Environment ---
            function drawBoardEnvironment() {
                p.background(BOARD_COLOR(p));
                p.stroke(200, 190, 150, 60);
                for (let y = 0; y < FLOOR_Y; y += 32) {
                    p.line(0, y, CANVAS_WIDTH, y);
                }
                p.noStroke();
                p.fill(WOOD_COLOR(p));
                p.rect(0, FLOOR_Y, CANVAS_WIDTH, CANVAS_HEIGHT - FLOOR_Y);
                p.stroke(120, 90, 50, 80);
                for (let x = 0; x < CANVAS_WIDTH; x += 60) {
                    p.line(x, FLOOR_Y, x, CANVAS_HEIGHT);
                }
                p.noStroke();
                p.fill(255, 255, 255, 18);
                p.ellipse(CANVAS_WIDTH/2, FLOOR_Y + 60, CANVAS_WIDTH/2, 40);
            }

            // --- Target/Wall ---
            function drawTarget() {
                p.fill(120, 120, 120);
                p.stroke(80, 80, 80);
                p.strokeWeight(3);
                // Wall above gap (from ceiling to gap)
                p.rect(wallX, 0, WALL_WIDTH, gapY, 6, 6, 0, 0);
                // Wall below gap (from gap to floor)
                p.rect(wallX, gapY + TARGET_GAP_HEIGHT, WALL_WIDTH, FLOOR_Y - (gapY + TARGET_GAP_HEIGHT), 0, 0, 6, 6);
                // Top and bottom wall caps
                p.rect(wallX, 0, WALL_WIDTH, 10, 6, 6, 0, 0);
                p.rect(wallX, FLOOR_Y, WALL_WIDTH, 10, 0, 0, 6, 6);
                // Gap highlight
                p.noStroke();
                p.fill(255, 255, 0, 90);
                p.rect(wallX - 6, gapY, WALL_WIDTH + 12, TARGET_GAP_HEIGHT, 8);
                // Target sign
                p.fill(80);
                p.textAlign(p.CENTER);
                p.textSize(13);
                p.text('TARGET', wallX + WALL_WIDTH/2, gapY + TARGET_GAP_HEIGHT/2);
                // Board details
                p.stroke(180, 180, 180, 80);
                for (let y = 0; y < FLOOR_Y; y += 18) {
                    p.line(wallX, y, wallX + WALL_WIDTH, y);
                }
            }

            // --- Trajectory preview ---
            function drawTrajectory() {
                trajectory = catapult.calculateTrajectory();
                p.stroke(255, 0, 0, 120);
                p.strokeWeight(3);
                p.noFill();
                for (let i = 0; i < trajectory.length - 1; i += 4) {
                    if (i % 8 < 4) {
                        p.line(trajectory[i].x, trajectory[i].y, 
                              trajectory[Math.min(i + 3, trajectory.length - 1)].x, 
                              trajectory[Math.min(i + 3, trajectory.length - 1)].y);
                    }
                }
            }
            function calculateTrajectory() {
                if (catapult) trajectory = catapult.calculateTrajectory();
            }

            // --- UI and Controls ---
            function launch() {
                if (launched || armAnimating) return;
                // Animate arm: cocked to release
                armAnimStart = -params.angle * Math.PI / 180;
                armAnimEnd = -Math.PI/6; // Release angle
                armAnimTime = p.millis();
                armAnimating = true;
            }
            function reset() {
                projectile = null;
                launched = false;
                armAnimating = false;
                particles = [];
                updateStatus('Ready to Launch');
                randomizeGapY(); // Randomize the gap on reset
                calculateTrajectory();
                document.getElementById('launchBtn').disabled = false;
                document.getElementById('message').style.opacity = '0';
            }
            function updateStatus(status) {
                document.getElementById('statusDisplay').textContent = status;
            }
            function updateStatsDisplay() {
                document.getElementById('shotCount').textContent = gameStats.shots;
                document.getElementById('hitCount').textContent = gameStats.hits;
                document.getElementById('streak').textContent = gameStats.bestStreak;
                const accuracy = gameStats.shots > 0 ? Math.round((gameStats.hits / gameStats.shots) * 100) : 0;
                document.getElementById('accuracy').textContent = accuracy + '%';
            }
            function setupControls() {
                const angleSlider = document.getElementById('angleSlider');
                const powerSlider = document.getElementById('powerSlider');
                angleSlider.oninput = function() {
                    params.angle = parseInt(this.value);
                    document.getElementById('angleValue').textContent = this.value + '¬∞';
                    calculateTrajectory();
                };
                powerSlider.oninput = function() {
                    params.power = parseInt(this.value);
                    document.getElementById('powerValue').textContent = this.value + '%';
                    calculateTrajectory();
                };
                document.getElementById('launchBtn').onclick = function() {
                    launch();
                };
                document.getElementById('resetBtn').onclick = function() {
                    reset();
                };
            }
            p.windowResized = function() {
                p.resizeCanvas(window.innerWidth, window.innerHeight);
                wallX = Math.floor(window.innerWidth * WALL_X_RATIO);
                // Randomize the gap on resize for consistency
                randomizeGapY();
                catapult.y = window.innerHeight - 100 - 40;
                calculateTrajectory();
            };
        });
    </script>
</body>
</html>
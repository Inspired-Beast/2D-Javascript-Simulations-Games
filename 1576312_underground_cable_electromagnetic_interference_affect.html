<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Underwater cable EM interference Simulation</title>
    <!-- Importing modules -->
    <script type="importmap">
    {
        "imports": {
            "p5": "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"
        }
    }
    </script>
    <!-- Styling -->
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #001122;
            color: white;
            font-family: 'Courier New', monospace;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ffff;
            margin-bottom: 20px;
        }
        
        .controls {
            text-align: center;
            margin-bottom: 20px;
        }
        
        button {
            background: #004466;
            color: #00ffff;
            border: 2px solid #00ffff;
            padding: 10px 20px;
            cursor: pointer;
            font-family: inherit;
            border-radius: 5px;
        }
        
        button:hover {
            background: #006688;
        }
        
        .info-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(0, 20, 40, 0.9);
            border: 2px solid #00ffff;
            padding: 15px;
            border-radius: 10px;
            min-width: 280px;
            font-size: 12px;
        }
        
        .metric {
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .metric-value {
            color: #00ff88;
            font-weight: bold;
        }
        
        .metric-value.warning {
            color: #ffaa00;
        }
        
        .metric-value.danger {
            color: #ff4444;
        }
        
        .waveform-container {
            margin-top: 15px;
            border-top: 1px solid #00ffff;
            padding-top: 10px;
        }
        
        .waveform-title {
            color: #00ffff;
            font-size: 11px;
            margin-bottom: 5px;
        }
        
        .emi-details {
            margin-top: 10px;
            border-top: 1px solid #666;
            padding-top: 10px;
            font-size: 11px;
        }
        
        .emi-zone-info {
            margin: 5px 0;
            color: #ff8888;
        }
        
        canvas {
            border: 2px solid #00ffff;
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Underwater Electromagnetic Interference Simulation</h1>
        <div class="controls">
            <button id="resetBtn">Reset Simulation</button>
        </div>
        <div id="simulation-container"></div>
        
        <div class="info-panel" id="infoPanel">
            <div class="metric">
                <span>Input Signal Power:</span>
                <span class="metric-value" id="inputPower">100.0 dBm</span>
            </div>
            <div class="metric">
                <span>Output Signal Power:</span>
                <span class="metric-value" id="outputPower">100.0 dBm</span>
            </div>
            <div class="metric">
                <span>Interference Level:</span>
                <span class="metric-value" id="interferenceLevel">0.0 dB</span>
            </div>
            <div class="metric">
                <span>Signal-to-Noise Ratio:</span>
                <span class="metric-value" id="snrRatio">∞ dB</span>
            </div>
            <div class="metric">
                <span>Bit Error Rate:</span>
                <span class="metric-value" id="bitErrorRate">0.00%</span>
            </div>
            <div class="metric">
                <span>Cable Depth:</span>
                <span class="metric-value" id="cableDepth">250m</span>
            </div>
            
            <div class="emi-details">
                <div style="color: #00ffff; font-weight: bold;">Active EMI Zones:</div>
                <div id="emiZonesList"></div>
            </div>
            
            <div class="waveform-container">
                <div class="waveform-title">Input Signal (Clean)</div>
                <canvas id="inputWaveform" width="240" height="40"></canvas>
                
                <div class="waveform-title" style="margin-top: 10px;">Output Signal (After EMI)</div>
                <canvas id="outputWaveform" width="240" height="40"></canvas>
            </div>
        </div>
    </div>
    <!-- Main Script -->
    <script type="module">
        import 'p5';
        
        let sketch = function(p) {
            // Environment constants
            const WATER_SURFACE = 150;
            const CABLE_DEPTH = 450;
            const SKY_HEIGHT = WATER_SURFACE;
            
            // Simulation variables
            let cable;
            let signals = [];
            let emiZones = [];
            let time = 0;
            let inputSignalPower = 100;
            let outputSignalPower = 100;
            let interferenceLevel = 0;
            let snrRatio = Infinity;
            let bitErrorRate = 0;
            
            // Global signal degradation tracking
            let globalSignalDegradation = 0;
            
            // Waveform data
            let inputWaveform = [];
            let outputWaveform = [];
            let waveformLength = 240;
            
            // Canvas references
            let inputCanvas, outputCanvas;
            let inputCtx, outputCtx;
            
            class Cable {
                constructor() {
                    this.y = CABLE_DEPTH;
                    this.thickness = 12;
                }
                
                draw() {
                    // Cable shadow on seabed
                    p.fill(20, 40, 60, 100);
                    p.noStroke();
                    p.ellipse(p.width/2, this.y + 15, p.width, 20);
                    
                    // Cable body (main conductor)
                    p.stroke(80, 80, 80);
                    p.strokeWeight(this.thickness);
                    p.line(0, this.y, p.width, this.y);
                    
                    // Cable outer shielding
                    p.stroke(120, 120, 120);
                    p.strokeWeight(this.thickness + 4);
                    p.line(0, this.y, p.width, this.y);
                    
                    // Cable inner core
                    p.stroke(200, 150, 100);
                    p.strokeWeight(this.thickness - 4);
                    p.line(0, this.y, p.width, this.y);
                    
                    // Cable markers every 100px
                    p.fill(255, 255, 0);
                    p.textSize(10);
                    for (let x = 100; x < p.width; x += 100) {
                        p.text(`${x}m`, x - 10, this.y - 20);
                        p.stroke(255, 255, 0, 100);
                        p.strokeWeight(1);
                        p.line(x, this.y - 15, x, this.y + 15);
                    }
                }
            }
            
            class Signal {
                constructor() {
                    this.x = -50;
                    this.y = cable.y;
                    this.speed = 3;
                    this.amplitude = 25;
                    this.frequency = 0.15;
                    this.phase = 0;
                    this.distortion = 0;
                    this.originalAmplitude = 25;
                    this.active = true;
                    this.interferenceHistory = [];
                    this.cumulativeDistortion = 0; // Track cumulative effect
                    this.signalIntegrity = 1.0; // Overall signal health
                }
                
                update() {
                    this.x += this.speed;
                    this.phase += this.frequency;
                    
                    // Calculate cumulative EMI effects based on all zones
                    this.distortion = 0;
                    this.cumulativeDistortion = 0;
                    let currentInterference = 0;
                    let totalEMIInfluence = 0;
                    
                    // Check interference from ALL EMI zones (not just nearby ones)
                    for (let emi of emiZones) {
                        let distance = p.dist(this.x, this.y, emi.x, emi.y);
                        let maxInfluenceDistance = emi.radius * 2.5; // Extended range
                        
                        if (distance < maxInfluenceDistance) {
                            let influence = p.map(distance, 0, maxInfluenceDistance, 1, 0);
                            influence = p.constrain(influence, 0, 1);
                            
                            // Apply stronger distortion effects
                            this.distortion += emi.intensity * influence * 0.8;
                            this.cumulativeDistortion += emi.intensity * influence * 0.15;
                            currentInterference += emi.intensity * influence * 15;
                            totalEMIInfluence += influence;
                        }
                    }
                    
                    // Apply multi-zone scaling - more zones = exponentially worse signal
                    if (emiZones.length > 1) {
                        let multiZoneMultiplier = Math.pow(1.3, emiZones.length - 1);
                        this.distortion *= multiZoneMultiplier;
                        this.cumulativeDistortion *= multiZoneMultiplier;
                        currentInterference *= multiZoneMultiplier;
                    }
                    
                    // Calculate signal integrity degradation
                    this.signalIntegrity = Math.max(0.1, 1 - this.cumulativeDistortion * 2);
                    
                    // Store interference history
                    this.interferenceHistory.push(currentInterference);
                    if (this.interferenceHistory.length > 10) {
                        this.interferenceHistory.shift();
                    }
                    
                    // Apply dramatic signal degradation based on EMI count and intensity
                    let degradationFactor = Math.min(this.distortion * 0.7, 0.9);
                    this.amplitude = this.originalAmplitude * (1 - degradationFactor) * this.signalIntegrity;
                    
                    if (this.x > p.width + 50) {
                        this.active = false;
                    }
                }
                
                draw() {
                    if (!this.active) return;
                    
                    p.push();
                    p.translate(this.x, this.y);
                    
                    // Calculate visual effects based on signal degradation
                    let baseSize = this.amplitude + p.sin(this.phase * 12) * 6;
                    let pulseSize = baseSize * this.signalIntegrity;
                    let jitter = this.distortion * p.random(-5, 5);
                    let transparency = p.map(this.signalIntegrity, 0.1, 1, 80, 180);
                    
                    // Color based on signal quality
                    let healthyColor = { r: 0, g: 255, b: 255 };
                    let degradedColor = { r: 255, g: 50, b: 50 };
                    
                    let colorMix = 1 - this.signalIntegrity;
                    let r = p.lerp(healthyColor.r, degradedColor.r, colorMix);
                    let g = p.lerp(healthyColor.g, degradedColor.g, colorMix);
                    let b = p.lerp(healthyColor.b, degradedColor.b, colorMix);
                    
                    // Main signal pulse with integrity-based sizing
                    p.fill(r, g, b, transparency);
                    p.noStroke();
                    p.ellipse(jitter, 0, pulseSize, pulseSize * 0.7);
                    
                    // Signal core becomes dimmer with interference
                    let coreAlpha = p.map(this.signalIntegrity, 0.1, 1, 30, 120);
                    p.fill(255, 255, 255, coreAlpha);
                    p.ellipse(jitter, 0, pulseSize * 0.5, pulseSize * 0.35);
                    
                    // Signal trail with dramatic interference artifacts
                    for (let i = 1; i < 15; i++) {
                        let alpha = p.map(i, 1, 15, transparency * 0.8, 0);
                        let trailJitter = this.distortion * p.sin(time * 0.1 + i) * 4;
                        let trailSize = pulseSize * (1 - i * 0.08) * this.signalIntegrity;
                        
                        // Make trail more erratic with interference
                        if (this.signalIntegrity < 0.5) {
                            trailJitter += p.random(-3, 3);
                            alpha *= p.random(0.3, 1);
                        }
                        
                        p.fill(r, g, b, alpha);
                        p.ellipse(-i * 6 + trailJitter, trailJitter * 0.5, trailSize, trailSize * 0.7);
                    }
                    
                    // Add interference sparks for severely degraded signals
                    if (this.signalIntegrity < 0.3) {
                        for (let i = 0; i < 3; i++) {
                            let sparkX = p.random(-15, 15);
                            let sparkY = p.random(-8, 8);
                            p.fill(255, 200, 100, p.random(50, 150));
                            p.ellipse(sparkX, sparkY, p.random(1, 3), p.random(1, 3));
                        }
                    }
                    
                    p.pop();
                }
                
                getWaveformValue() {
                    let baseValue = p.sin(this.phase * 12) * this.amplitude;
                    let noise = this.distortion * (p.random(-12, 12) + p.sin(time * 0.3) * 8);
                    let harmonics = this.distortion * p.sin(this.phase * 36) * 5;
                    return baseValue + noise + harmonics;
                }
                
                getCurrentInterference() {
                    return this.interferenceHistory.length > 0 ? 
                           this.interferenceHistory[this.interferenceHistory.length - 1] : 0;
                }
            }
            
            class EMIZone {
                constructor(x, y) {
                    // Position near cable if not specified
                    this.x = x || p.random(100, p.width - 100);
                    this.y = y || p.random(CABLE_DEPTH - 80, CABLE_DEPTH + 80);
                    this.radius = p.random(70, 130);
                    this.intensity = p.random(0.8, 1.0);
                    this.growthRate = p.random(-0.3, 0.3);
                    this.maxRadius = p.random(90, 160);
                    this.minRadius = 50;
                    this.life = p.random(400, 800);
                    this.maxLife = this.life;
                    this.noiseOffset = p.random(1000);
                    this.id = Math.floor(p.random(1000, 9999));
                    this.type = p.random(['Magnetic', 'Electric', 'Electromagnetic']);
                    this.frequency = p.random(1, 100).toFixed(1);
                    this.phaseShift = p.random(0, p.TWO_PI);
                    this.harmonicFreq = p.random(0.1, 0.5);
                    this.noiseIntensity = p.random(1.0, 2.0);
                }
                
                update() {
                    this.life--;
                    this.radius += this.growthRate;
                    
                    // Subtle movement using Perlin noise
                    this.x += (p.noise(time * 0.008 + this.noiseOffset) - 0.5) * 0.3;
                    this.y += (p.noise(time * 0.008 + this.noiseOffset + 100) - 0.5) * 0.2;
                    
                    // Keep EMI zones near cable
                    this.y = p.constrain(this.y, CABLE_DEPTH - 100, CABLE_DEPTH + 100);
                    this.x = p.constrain(this.x, 50, p.width - 50);
                    
                    // Dynamic intensity fluctuation
                    this.intensity = p.map(p.noise(time * 0.02 + this.noiseOffset), 0, 1, 0.7, 1.0);
                    
                    // Radius bounds
                    if (this.radius > this.maxRadius || this.radius < this.minRadius) {
                        this.growthRate *= -0.8;
                    }
                    
                    return this.life > 0;
                }
                
                draw() {
                    let alpha = p.map(this.life, 0, this.maxLife, 0, 150);
                    
                    // EMI field visualization with multiple layers
                    for (let r = this.radius; r > 0; r -= 8) {
                        let fieldAlpha = alpha * (1 - r / this.radius) * this.intensity * 0.6;
                        let colorShift = p.sin(time * 0.05 + r * 0.1) * 30;
                        p.fill(255 + colorShift, 80, 80, fieldAlpha);
                        p.noStroke();
                        p.ellipse(this.x, this.y, r * 2, r * 2);
                    }
                    
                    // EMI center with pulsing effect
                    let pulseSize = 8 + p.sin(time * 0.1) * 3;
                    p.fill(255, 150, 150, alpha);
                    p.ellipse(this.x, this.y, pulseSize, pulseSize);
                    
                    // Electric field lines
                    p.stroke(255, 200, 200, alpha * 0.7);
                    p.strokeWeight(1.5);
                    for (let angle = 0; angle < p.TWO_PI; angle += p.PI / 8) {
                        let x1 = this.x + p.cos(angle + time * 0.02) * this.radius * 0.4;
                        let y1 = this.y + p.sin(angle + time * 0.02) * this.radius * 0.4;
                        let x2 = this.x + p.cos(angle + time * 0.02) * this.radius * 0.9;
                        let y2 = this.y + p.sin(angle + time * 0.02) * this.radius * 0.9;
                        p.line(x1, y1, x2, y2);
                    }
                }
                
                affects(x, y) {
                    let distance = p.dist(x, y, this.x, this.y);
                    return distance < this.radius * 2.5; // Extended range
                }
                
                getInfo() {
                    return {
                        id: this.id,
                        type: this.type,
                        frequency: this.frequency,
                        intensity: (this.intensity * 100).toFixed(1),
                        distance: this.radius.toFixed(0)
                    };
                }
            }
            
            function calculateGlobalSignalDegradation() {
                // Calculate overall signal degradation based on all EMI zones
                globalSignalDegradation = 0;
                
                for (let emi of emiZones) {
                    let distance = p.dist(p.width/2, CABLE_DEPTH, emi.x, emi.y);
                    let maxDistance = emi.radius * 2.5;
                    
                    if (distance < maxDistance) {
                        let influence = p.map(distance, 0, maxDistance, 1, 0);
                        globalSignalDegradation += emi.intensity * influence * 0.3;
                    }
                }
                
                // Apply exponential scaling for multiple EMI zones
                if (emiZones.length > 1) {
                    globalSignalDegradation *= Math.pow(1.4, emiZones.length - 1);
                }
                
                globalSignalDegradation = Math.min(globalSignalDegradation, 0.95);
            }
            
            function drawEnvironment() {
                // Sky gradient
                for (let y = 0; y < SKY_HEIGHT; y++) {
                    let alpha = p.map(y, 0, SKY_HEIGHT, 0.9, 0.3);
                    p.stroke(135 * alpha, 206 * alpha, 235 * alpha);
                    p.line(0, y, p.width, y);
                }
                
                // Clouds
                p.fill(255, 255, 255, 100);
                p.noStroke();
                for (let i = 0; i < 5; i++) {
                    let x = (time * 0.2 + i * 200) % (p.width + 100);
                    let y = 30 + p.sin(time * 0.01 + i) * 20;
                    p.ellipse(x, y, 60, 30);
                    p.ellipse(x + 20, y, 40, 20);
                    p.ellipse(x - 15, y, 35, 25);
                }
                
                // Underwater gradient
                for (let y = WATER_SURFACE; y < p.height; y++) {
                    let depth = y - WATER_SURFACE;
                    let alpha = p.map(depth, 0, p.height - WATER_SURFACE, 0.3, 0.9);
                    let blue = p.map(depth, 0, p.height - WATER_SURFACE, 150, 50);
                    p.stroke(0, blue * alpha, 120 * alpha);
                    p.line(0, y, p.width, y);
                }
                
                // Underwater particles and marine life
                p.fill(100, 150, 200, 80);
                p.noStroke();
                for (let i = 0; i < 30; i++) {
                    let x = (time * 0.3 + i * 35) % (p.width + 50);
                    let y = WATER_SURFACE + 50 + p.sin(time * 0.008 + i) * 100;
                    p.ellipse(x, y, 2, 2);
                }
                
                // Seabed
                p.fill(101, 67, 33);
                p.noStroke();
                p.rect(0, CABLE_DEPTH + 20, p.width, p.height - CABLE_DEPTH - 20);
                
                // Seabed texture
                p.fill(139, 90, 43, 100);
                for (let x = 0; x < p.width; x += 20) {
                    let height = p.noise(x * 0.01) * 15;
                    p.rect(x, CABLE_DEPTH + 20, 20, height);
                }
            }
            
            function updateWaveforms() {
                // Clean input signal - always the same
                let inputValue = p.sin(time * 0.15) * 18;
                
                // Start with clean signal for output
                let outputValue = inputValue;
                
                // Apply EXTREME interference effects based on EMI zone count
                if (emiZones.length > 0) {
                    let totalAmplitudeReduction = 0;
                    let totalNoise = 0;
                    let totalHarmonics = 0;
                    let totalDistortion = 0;
                    
                    // Calculate cumulative effects from all EMI zones
                    for (let emi of emiZones) {
                        // Calculate distance from cable center
                        let distance = p.dist(p.width/2, CABLE_DEPTH, emi.x, emi.y);
                        
                        // Extended influence range for dramatic effects
                        if (distance < emi.radius * 3) {
                            let influence = p.map(distance, 0, emi.radius * 3, 1, 0);
                            influence = p.constrain(influence, 0, 1);
                            
                            // EXTREME amplitude reduction
                            totalAmplitudeReduction += emi.intensity * influence * 0.8;
                            
                            // MASSIVE noise injection
                            let noiseComponent = (p.random(-1, 1) * 15 + 
                                                p.sin(time * 0.3 + emi.noiseOffset) * 12 +
                                                p.sin(time * 0.7 + emi.noiseOffset) * 8) * 
                                               emi.intensity * influence * emi.noiseIntensity;
                            totalNoise += noiseComponent;
                            
                            // POWERFUL harmonic interference
                            let harmonic1 = p.sin(time * emi.harmonicFreq + emi.phaseShift) * 
                                          emi.intensity * influence * 20;
                            let harmonic2 = p.sin(time * emi.harmonicFreq * 2.5 + emi.phaseShift) * 
                                          emi.intensity * influence * 12;
                            let harmonic3 = p.sin(time * emi.harmonicFreq * 4 + emi.phaseShift) * 
                                          emi.intensity * influence * 6;
                            totalHarmonics += harmonic1 + harmonic2 + harmonic3;
                            
                            // Signal distortion
                            totalDistortion += emi.intensity * influence * 0.5;
                        }
                    }
                    
                    // Apply exponential scaling for multiple EMI zones
                    if (emiZones.length > 1) {
                        let multiZoneMultiplier = Math.pow(1.5, emiZones.length - 1);
                        totalAmplitudeReduction *= multiZoneMultiplier;
                        totalNoise *= multiZoneMultiplier;
                        totalHarmonics *= multiZoneMultiplier;
                        totalDistortion *= multiZoneMultiplier;
                    }
                    
                    // Apply EXTREME signal degradation
                    
                    // 1. Massive amplitude reduction
                    let amplitudeMultiplier = 1 - Math.min(totalAmplitudeReduction, 0.95);
                    outputValue *= amplitudeMultiplier;
                    
                    // 2. Add enormous noise
                    outputValue += totalNoise;
                    
                    // 3. Add powerful harmonic interference
                    outputValue += totalHarmonics;
                    
                    // 4. Cross-modulation for multiple EMI zones
                    if (emiZones.length > 1) {
                        let crossModulation = 0;
                        for (let i = 0; i < emiZones.length; i++) {
                            for (let j = i + 1; j < emiZones.length; j++) {
                                let emi1 = emiZones[i];
                                let emi2 = emiZones[j];
                                crossModulation += p.sin(time * (emi1.harmonicFreq + emi2.harmonicFreq) * 0.8) * 
                                                 emi1.intensity * emi2.intensity * 10;
                            }
                        }
                        outputValue += crossModulation;
                    }
                    
                    // 5. Add severe signal phase distortion
                    let phaseNoise = p.sin(time * 0.35 + totalDistortion * 8) * totalDistortion * 15;
                    outputValue += phaseNoise;
                    
                    // 6. Add frequent impulse noise spikes
                    if (p.random() < 0.08 * emiZones.length) {
                        outputValue += p.random(-30, 30);
                    }
                    
                    // 7. Severe signal clipping and limiting
                    if (Math.abs(outputValue) > 20) {
                        outputValue = p.constrain(outputValue, -20, 20);
                    }
                }
                
                // Update waveform arrays
                inputWaveform.push(inputValue);
                outputWaveform.push(outputValue);
                
                if (inputWaveform.length > waveformLength) {
                    inputWaveform.shift();
                    outputWaveform.shift();
                }
                
                // Draw waveforms
                drawWaveform(inputCtx, inputWaveform, 'rgb(0, 255, 255)', 'Clean Signal');
                drawWaveform(outputCtx, outputWaveform, 'rgb(255, 100, 100)', 'Interfered Signal');
            }
            
            function drawWaveform(ctx, data, color, label) {
                ctx.clearRect(0, 0, 240, 40);
                
                // Grid lines
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i <= 240; i += 40) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 40);
                    ctx.stroke();
                }
                for (let i = 0; i <= 40; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(0, i);
                    ctx.lineTo(240, i);
                    ctx.stroke();
                }
                
                // Waveform
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let i = 0; i < data.length; i++) {
                    let x = i;
                    let y = 20 + data[i] * 0.6;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Center line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, 20);
                ctx.lineTo(240, 20);
                ctx.stroke();
            }
            
            function updateMetrics() {
                // Calculate interference from all EMI zones 
                let totalInterference = 0;
                for (let emi of emiZones) {
                    let distance = p.dist(p.width/2, CABLE_DEPTH, emi.x, emi.y);
                    if (distance < emi.radius * 3) {
                        let influence = p.map(distance, 0, emi.radius * 3, 1, 0);
                        totalInterference += emi.intensity * influence * 40;
                    }
                }
                
                // Apply exponential scaling for multiple EMI zones
                if (emiZones.length > 1) {
                    totalInterference *= Math.pow(1.6, emiZones.length - 1);
                }
                
                // Get current signal interference
                let currentSignalInterference = 0;
                if (signals.length > 0) {
                    currentSignalInterference = signals[0].getCurrentInterference();
                }
                
                interferenceLevel = Math.max(totalInterference, currentSignalInterference);
                outputSignalPower = Math.max(10, inputSignalPower - interferenceLevel * 2.5);
                snrRatio = interferenceLevel > 0 ? (inputSignalPower - interferenceLevel) : Infinity;
                bitErrorRate = Math.min(40, interferenceLevel * 0.8);
                
                // Update UI with color coding
                document.getElementById('inputPower').textContent = inputSignalPower.toFixed(1) + ' dBm';
                
                let outputElement = document.getElementById('outputPower');
                outputElement.textContent = outputSignalPower.toFixed(1) + ' dBm';
                outputElement.className = 'metric-value ' + 
                    (outputSignalPower < 60 ? 'danger' : outputSignalPower < 80 ? 'warning' : '');
                
                let interferenceElement = document.getElementById('interferenceLevel');
                interferenceElement.textContent = interferenceLevel.toFixed(1) + ' dB';
                interferenceElement.className = 'metric-value ' + 
                    (interferenceLevel > 30 ? 'danger' : interferenceLevel > 20 ? 'warning' : '');
                
                let snrElement = document.getElementById('snrRatio');
                snrElement.textContent = snrRatio === Infinity ? '∞ dB' : snrRatio.toFixed(1) + ' dB';
                snrElement.className = 'metric-value ' + 
                    (snrRatio < 0 ? 'danger' : snrRatio < 10 ? 'warning' : '');
                
                let berElement = document.getElementById('bitErrorRate');
                berElement.textContent = bitErrorRate.toFixed(2) + '%';
                berElement.className = 'metric-value ' + 
                    (bitErrorRate > 15 ? 'danger' : bitErrorRate > 8 ? 'warning' : '');
                
                document.getElementById('cableDepth').textContent = '250m';
                
                // Update EMI zones list
                let emiList = document.getElementById('emiZonesList');
                emiList.innerHTML = '';
                emiZones.forEach(emi => {
                    let info = emi.getInfo();
                    let div = document.createElement('div');
                    div.className = 'emi-zone-info';
                    div.innerHTML = `Zone ${info.id}: ${info.type} ${info.frequency}MHz (${info.intensity}%)`;
                    emiList.appendChild(div);
                });
                
                if (emiZones.length === 0) {
                    let div = document.createElement('div');
                    div.style.color = '#888';
                    div.textContent = 'No active EMI zones';
                    emiList.appendChild(div);
                }
            }
            
            function resetSimulation() {
                signals = [];
                emiZones = [];
                inputWaveform = [];
                outputWaveform = [];
                time = 0;
                inputSignalPower = 100;
                outputSignalPower = 100;
                interferenceLevel = 0;
                snrRatio = Infinity;
                bitErrorRate = 0;
                globalSignalDegradation = 0;
            }
            
            function addEMIZone() {
                // Add EMI zone near the cable
                let x = p.random(100, p.width - 100);
                let y = CABLE_DEPTH + p.random(-60, 60);
                emiZones.push(new EMIZone(x, y));
            }
            
            p.setup = function() {
                let canvas = p.createCanvas(1000, 600);
                canvas.parent('simulation-container');
                
                cable = new Cable();
                
                // Add initial EMI zones near cable
                for (let i = 0; i < 2; i++) {
                    addEMIZone();
                }
                
                // Get waveform canvases
                inputCanvas = document.getElementById('inputWaveform');
                outputCanvas = document.getElementById('outputWaveform');
                inputCtx = inputCanvas.getContext('2d');
                outputCtx = outputCanvas.getContext('2d');
                
                // Event listeners
                document.getElementById('resetBtn').addEventListener('click', resetSimulation);
            };
            
            p.draw = function() {
                // Calculate global signal degradation
                calculateGlobalSignalDegradation();
                
                // Draw environment layers
                drawEnvironment();
                
                // Draw cable
                cable.draw();
                
                // Spawn new signals periodically
                if (p.frameCount % 100 === 0) {
                    signals.push(new Signal());
                }
                
                // Occasionally add new EMI zones near cable
                if (p.random() < 0.008 && emiZones.length < 4) {
                    addEMIZone();
                }
                
                // Update and draw EMI zones
                emiZones = emiZones.filter(emi => {
                    emi.update();
                    emi.draw();
                    return emi.life > 0;
                });
                
                // Update and draw signals
                signals = signals.filter(signal => {
                    signal.update();
                    signal.draw();
                    return signal.active;
                });
                
                // Update waveforms and metrics
                updateWaveforms();
                updateMetrics();
                
                // Environment labels
                p.fill(255, 255, 255, 200);
                p.textSize(14);
                p.text('Sky', 20, 30);
                p.text('Water Surface', 20, WATER_SURFACE - 10);
                p.text('Submarine Cable (250m depth)', 20, CABLE_DEPTH - 38);
                p.text('Seabed', 20, CABLE_DEPTH + 50);
                
                // Signal direction indicator
                p.fill(0, 255, 255);
                p.textSize(12);
                p.text('Signal Direction →', 20, CABLE_DEPTH + 18);
                
                time++;
            };
        };
        
        new p5(sketch);
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Complete Vine & Root System Simulation</title>
  <style>
    /* Basic page styling */
    body { margin:0; overflow:hidden; background:#eaf4ea; font-family:sans-serif; }
    #canvas-container { position:relative; width:100vw; height:100vh; }
    /* UI panel styling */
    .ui {
      position:absolute;top:14px;left:14px;z-index:9;
      padding:14px 18px;border-radius:10px;background:#ffffffdd;
      box-shadow:0 4px 14px #0001;font-size:14px;
      user-select:none;
    }
    .ui h3{margin:0 0 6px 0;font-size:15px;color:#2e5b2e}
    .ui button{
      padding:6px 14px;border:none;border-radius:6px;
      background:#4a7c59;color:#fff;cursor:pointer;font-size:13px;margin:2px;
    }
    .ui button:hover{background:#5c8c69}
    small {
      display: block;
      margin-top: 8px;
      font-size: 12px;
      color: #555;
    }
  </style>
  <!-- Import map for p5.js ES module -->
  <script type="importmap">
    {
      "imports": {
        "p5": "https://cdn.jsdelivr.net/npm/p5@1.9.0/+esm"
      }
    }
  </script>
</head>
<body>
<div class="ui">
  <h3>ðŸŒ± Complete Plant System</h3>
  <button id="reset-btn">ðŸ”„ Reset</button>
  <button id="toggle-nutrients">ðŸ’§ Toggle Nutrients</button>
  <small>
    â€¢ Single click to add pipe<br>
    â€¢ Double click to add window<br>
    â€¢ Drag obstacles to reposition<br>
  </small>
</div>
<div id="canvas-container"></div>
<script type="module">
  import p5 from "p5";

  // p5 sketch in instance mode
  const sketch = (p) => {
    // --- Parameters controlling simulation behavior and appearance ---
    const WALL_X = 0.5; // Horizontal center position of the wall (relative to canvas width)
    const WALL_W = 420; // Width of the wall
    const SOIL_HEIGHT = 260; // Height of the soil area at bottom
    const SEG_LEN = 5; // Length of each vine segment
    const SEG_RAD = 2; // Radius (thickness) of vine segments
    const ROOT_SEG_LEN = 3; // Length of each root segment
    const GROW_INTERVAL = 70; // Time interval (ms) between vine growth steps
    const ROOT_GROW_INTERVAL = 120; // Time interval (ms) between root growth steps
    const BASE_BRANCH_CHANCE = 0.05; // Base chance for vine to branch
    const TOP_BRANCH_CHANCE = 0.01; // Branch chance near top of vine
    const ROOT_BRANCH_CHANCE = 0.08; // Chance for root to branch
    const OBSTACLE_MARGIN = 8; // Margin around obstacles for collision detection
    const MIN_BRANCH_DIST = 10; // Minimum distance between branches
    const MAX_BRANCH_DEPTH = 4; // Maximum depth of vine branching
    const MAX_ROOT_DEPTH = 3; // Maximum depth of root branching
    const PIPE_ARC_LIMIT = 15; // Max steps to follow pipe arc before resuming normal growth
    const LOOKAHEAD_REDUCTION = 0.9; // Factor to reduce lookahead distance for obstacle detection
    const MAX_SEGMENTS = 5000; // Max total vine segments allowed
    const MAX_ROOT_SEGMENTS = 2000; // Max total root segments allowed
    const GRAVITY = 0.015; // Gravity effect on vine growth direction
    const ROOT_GRAVITY = 0.02; // Gravity effect on root growth direction
    const DIRECTIONAL_BIAS = 0.12; // Upward bias for vine growth direction
    const NOISE_SCALE = 0.01; // Scale for Perlin noise used in growth direction variation
    const NOISE_STRENGTH = 0.15; // Strength of noise effect on growth direction
    const LEAF_DENSITY = 0.4; // Density factor for leaf placement on vine segments

    // Arrays to hold simulation objects
    let obstacles = []; // Obstacles like windows and pipes
    let shoots = []; // Vine branches
    let roots = []; // Root branches
    let nutrients = []; // Nutrient particles in soil
    let soilParticles = []; // Soil visual particles
    let nutrientPulses = []; // Visual pulses showing nutrient flow

    // Variables for dragging obstacles
    let dragging = null, dragDX = 0, dragDY = 0;

    // Timing variables for growth and spawning
    let lastGrow = 0;
    let lastRootGrow = 0;
    let lastNutrientSpawn = 0;

    // Variables for click timing to distinguish single/double clicks
    let lastClickTime = 0;
    let clickTimeout = null;

    // Graphics buffers for wall and soil textures
    let wallGraphic, soilGraphic;

    // Flags to toggle display of roots, nutrients, and soil particles
    let showRoots = true;
    let showNutrients = true;
    let showSoilParticles = true;
    let nutrientFlow = true;

    // Helper functions to calculate wall and soil boundaries dynamically
    const WALL_LEFT = () => p.width * WALL_X - WALL_W / 2;
    const WALL_RIGHT = () => p.width * WALL_X + WALL_W / 2;
    const SOIL_TOP = () => p.height - SOIL_HEIGHT;

    // Class representing a window obstacle
    class WindowOb {
      constructor(x, y, w = 70, h = 50) {
        this.x = x; this.y = y; this.w = w; this.h = h; this.type = 'window';
      }
      // Check if a point is inside the window plus margin
      contains(px, py) {
        return px > this.x - this.w / 2 - OBSTACLE_MARGIN && px < this.x + this.w / 2 + OBSTACLE_MARGIN &&
          py > this.y - this.h / 2 - OBSTACLE_MARGIN && py < this.y + this.h / 2 + OBSTACLE_MARGIN;
      }
      // Find nearest vertical edge (left or right) to a point
      nearestEdge(px) {
        let left = this.x - this.w / 2 - OBSTACLE_MARGIN, right = this.x + this.w / 2 + OBSTACLE_MARGIN;
        return (Math.abs(px - left) < Math.abs(px - right)) ? left : right;
      }
      // Get closest point on window perimeter to a given point
      getPerimeterPoint(px, py) {
        let left = this.x - this.w / 2 - OBSTACLE_MARGIN;
        let right = this.x + this.w / 2 + OBSTACLE_MARGIN;
        let top = this.y - this.h / 2 - OBSTACLE_MARGIN;
        let bottom = this.y + this.h / 2 + OBSTACLE_MARGIN;
        let distToLeft = Math.abs(px - left);
        let distToRight = Math.abs(px - right);
        let distToTop = Math.abs(py - top);
        let distToBottom = Math.abs(py - bottom);
        let minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
        if (minDist === distToLeft) return { x: left, y: py };
        if (minDist === distToRight) return { x: right, y: py };
        if (minDist === distToTop) return { x: px, y: top };
        return { x: px, y: bottom };
      }
    }

    // Class representing a pipe obstacle (circular)
    class PipeOb {
      constructor(x, y, r = 25) {
        this.x = x;
        this.y = y;
        this.r = r;
        this.type = 'pipe';
        this.seed = p.random(10000); // Seed for random appearance
      }
      // Check if a point is inside the pipe plus margin
      contains(px, py) {
        return p.dist(px, py, this.x, this.y) < this.r + OBSTACLE_MARGIN;
      }
      // Get point on pipe perimeter closest to a given point
      getPerimeterPoint(px, py) {
        let angle = p.atan2(py - this.y, px - this.x);
        let perimeterX = this.x + p.cos(angle) * (this.r + OBSTACLE_MARGIN);
        let perimeterY = this.y + p.sin(angle) * (this.r + OBSTACLE_MARGIN);
        return { x: perimeterX, y: perimeterY };
      }
    }

    // Class representing a single segment of a vine branch
    class Segment {
      constructor(x, y, branch, segmentIndex) {
        this.pos = p.createVector(x, y);
        this.branch = branch;
        this.segmentIndex = segmentIndex;
        this.hasLeaf = this.shouldHaveLeaf(); // Determine if this segment has a leaf
        this.leafAngle = p.random(-p.PI / 2, p.PI / 2);
        this.leafSize = p.random(0.9, 1.4) * (1.3 - 0.2 * branch.depth);
        this.leafType = p.random() < 0.7 ? 'normal' : 'small';
      }
      // Logic to decide if a leaf should be placed on this segment
      shouldHaveLeaf() {
        if (this.segmentIndex < 3) return false; // No leaves on first few segments
        let depthFactor = 1.2 - 0.25 * this.branch.depth;
        let heightFactor = p.map(this.pos.y, p.height, 0, 0.8, 1.2);
        let probability = depthFactor * heightFactor * LEAF_DENSITY;
        let interval = this.branch.depth === 0 ? 4 : (this.branch.depth === 1 ? 5 : 7);
        return (this.segmentIndex % interval === 0 && p.random() < probability) ||
          (p.random() < probability * 0.3);
      }
    }

    // Class representing a single segment of a root branch
    class RootSegment {
      constructor(x, y, branch, segmentIndex) {
        this.pos = p.createVector(x, y);
        this.branch = branch;
        this.segmentIndex = segmentIndex;
        this.absorptionRate = p.random(0.3, 0.8); // Rate at which nutrients are absorbed
        this.lastAbsorption = 0; // Timestamp of last absorption event
        this.absorbHighlight = 0; // Visual highlight intensity for absorption
      }
    }

    // Class representing a vine shoot (branch)
    class Shoot {
      constructor(x, y, dir, depth = 0, parent = null) {
        this.segs = []; // Array of segments composing this shoot
        this.dir = dir.copy().normalize(); // Current growth direction vector
        this.depth = depth; // Branching depth level
        this.growing = true; // Whether this shoot is currently growing
        this.state = 'normal'; // Growth state (normal, followingWindow, followingPipe)
        this.targetOb = null; // Target obstacle being followed if any
        this.edgeX = null; // Edge x-coordinate for window following
        this.lastBranchAt = 0; // Segment index of last branch created
        this.segmentCount = 0; // Number of segments created
        this.pipeArcSteps = 0; // Steps taken while following pipe arc
        this.noiseSeed = p.random(10000); // Seed for noise-based growth variation
        this.segs.push(new Segment(x, y, this, this.segmentCount++)); // Initial segment
      }
      // Get the tip (last segment) of this shoot
      tip() { return this.segs[this.segs.length - 1]; }
      // Perform one growth step for this shoot
      stepGrowth() {
        if (!this.growing) return; // Stop if not growing

        // Calculate total segments across all shoots to limit growth
        let totalSegments = shoots.reduce((sum, shoot) => sum + shoot.segs.length, 0);
        if (totalSegments > MAX_SEGMENTS) {
          this.growing = false;
          return;
        }

        let t = this.tip();
        let pos = t.pos.copy();
        let dir = this.dir.copy();
        let next = null;

        // Handle special growth states when following obstacles
        if (this.state === 'followingWindow' && this.targetOb) {
          // Logic to grow around window edges
          let left = this.targetOb.x - this.targetOb.w / 2 - OBSTACLE_MARGIN;
          let right = this.targetOb.x + this.targetOb.w / 2 + OBSTACLE_MARGIN;
          let top = this.targetOb.y - this.targetOb.h / 2 - OBSTACLE_MARGIN;
          let bottom = this.targetOb.y + this.targetOb.h / 2 + OBSTACLE_MARGIN;

          if (p.abs(pos.x - left) < 3) {
            if (pos.y > top) next = p.createVector(left, pos.y - SEG_LEN);
            else next = p.createVector(pos.x + SEG_LEN, top);
          } else if (p.abs(pos.x - right) < 3) {
            if (pos.y > top) next = p.createVector(right, pos.y - SEG_LEN);
            else next = p.createVector(pos.x - SEG_LEN, top);
          } else if (p.abs(pos.y - top) < 3) {
            if (this.edgeX === left) {
              next = p.createVector(pos.x + SEG_LEN, top);
              if (pos.x >= this.targetOb.x) {
                this.state = 'normal';
                this.targetOb = null;
                this.dir = p.createVector(0, -1);
              }
            } else {
              next = p.createVector(pos.x - SEG_LEN, top);
              if (pos.x <= this.targetOb.x) {
                this.state = 'normal';
                this.targetOb = null;
                this.dir = p.createVector(0, -1);
              }
            }
          } else {
            let perimPoint = this.targetOb.getPerimeterPoint(pos.x, pos.y);
            next = p.createVector(perimPoint.x, perimPoint.y);
          }
        }
        else if (this.state === 'followingPipe' && this.targetOb) {
          // Logic to grow around pipe perimeter
          let angle = p.atan2(pos.y - this.targetOb.y, pos.x - this.targetOb.x);
          angle -= 0.15 - p.random(0.03);
          let radius = this.targetOb.r + OBSTACLE_MARGIN;
          let nx = this.targetOb.x + p.cos(angle) * radius;
          let ny = this.targetOb.y + p.sin(angle) * radius - 0.8;
          next = p.createVector(nx, ny);
          this.pipeArcSteps = (this.pipeArcSteps || 0) + 1;
          if (ny < this.targetOb.y - radius - 5 || this.pipeArcSteps > PIPE_ARC_LIMIT) {
            this.state = 'normal';
            this.targetOb = null;
            this.dir = p.createVector(0, -1);
            this.pipeArcSteps = 0;
          }
        }
        else {
          // Normal growth: look ahead for obstacles and adjust direction
          let lookahead = pos.copy().add(dir.copy().mult(SEG_LEN * 1.5 * LOOKAHEAD_REDUCTION));
          let found = false;
          for (let ob of obstacles) {
            if (ob.contains(lookahead.x, lookahead.y)) {
              found = true;
              if (ob.type === 'window') {
                this.state = 'followingWindow';
                this.targetOb = ob;
                this.edgeX = ob.nearestEdge(pos.x);
                let perimPoint = ob.getPerimeterPoint(pos.x, pos.y);
                next = p.createVector(perimPoint.x, perimPoint.y);
                break;
              } else if (ob.type === 'pipe') {
                this.state = 'followingPipe';
                this.targetOb = ob;
                let perimPoint = ob.getPerimeterPoint(pos.x, pos.y);
                next = p.createVector(perimPoint.x, perimPoint.y);
                this.pipeArcSteps = 0;
                break;
              }
            }
          }
          if (!found) {
            // Apply noise and gravity to growth direction
            let noiseVal = p.noise(this.noiseSeed, this.segs.length * NOISE_SCALE);
            let angle = p.map(noiseVal, 0, 1, -NOISE_STRENGTH, NOISE_STRENGTH);
            dir.rotate(angle);
            dir.y += GRAVITY;
            dir.y -= DIRECTIONAL_BIAS;
            dir.normalize();
            let segmentLength = SEG_LEN + p.random(-0.5, 0.8);
            let nx = p.constrain(pos.x + dir.x * segmentLength, WALL_LEFT() + SEG_RAD, WALL_RIGHT() - SEG_RAD);
            let ny = pos.y + dir.y * segmentLength;
            next = p.createVector(nx, ny);
            this.dir = p.createVector(nx - pos.x, ny - pos.y).normalize();
          }
        }

        // Add new segment if next position is determined
        if (next) {
          this.segs.push(new Segment(next.x, next.y, this, this.segmentCount++));
          if (next.y < 30) this.growing = false; // Stop growing if near top of canvas
        }

        // Possibly create a new branch if conditions are met
        if (
          this.depth < MAX_BRANCH_DEPTH &&
          this.segs.length > 8 &&
          this.segs.length - this.lastBranchAt > MIN_BRANCH_DIST &&
          totalSegments < MAX_SEGMENTS * 0.8
        ) {
          let y = this.tip().pos.y;
          let branchChance = p.map(y, p.height, 0, BASE_BRANCH_CHANCE, TOP_BRANCH_CHANCE, true);
          if (this.depth <= 1) branchChance *= 1.8;
          if (p.random() < branchChance) {
            let angle = p.random(-p.PI / 2.8, p.PI / 2.8);
            let upwardness = p.map(y, p.height, 0, 0.4, 0.85, true);
            let branchDir = p5.Vector.lerp(
              this.dir.copy().rotate(angle),
              p.createVector(0, -1),
              upwardness
            );
            shoots.push(new Shoot(this.tip().pos.x, this.tip().pos.y, branchDir, this.depth + 1, this));
            this.lastBranchAt = this.segs.length;
          }
        }
      }
    }

    // Class representing a root branch
    class Root {
      constructor(x, y, dir, depth = 0) {
        this.segs = []; // Segments composing this root
        this.dir = dir.copy().normalize(); // Growth direction
        this.depth = depth; // Branching depth
        this.growing = true; // Whether root is growing
        this.lastBranchAt = 0; // Last branch segment index
        this.segmentCount = 0; // Number of segments
        this.noiseSeed = p.random(10000); // Noise seed for growth variation
        this.segs.push(new RootSegment(x, y, this, this.segmentCount++)); // Initial segment
      }
      // Get tip segment of root
      tip() { return this.segs[this.segs.length - 1]; }
      // Perform one growth step for root
      stepGrowth() {
        if (!this.growing) return;

        // Limit total root segments
        let totalRootSegments = roots.reduce((sum, root) => sum + root.segs.length, 0);
        if (totalRootSegments > MAX_ROOT_SEGMENTS) {
          this.growing = false;
          return;
        }

        let t = this.tip();
        let pos = t.pos.copy();
        let dir = this.dir.copy();

        // Apply noise and gravity to root growth direction
        let noiseVal = p.noise(this.noiseSeed, this.segs.length * NOISE_SCALE * 0.5);
        let angle = p.map(noiseVal, 0, 1, -NOISE_STRENGTH * 0.8, NOISE_STRENGTH * 0.8);
        dir.rotate(angle);
        dir.y += ROOT_GRAVITY;
        dir.normalize();

        // Calculate next position constrained within soil and wall boundaries
        let segmentLength = ROOT_SEG_LEN + p.random(-0.3, 0.5);
        let nx = p.constrain(pos.x + dir.x * segmentLength, WALL_LEFT() + 10, WALL_RIGHT() - 10);
        let ny = p.constrain(pos.y + dir.y * segmentLength, SOIL_TOP() + 5, p.height - 10);

        // Stop growing if hitting boundaries
        if (ny > p.height - 10 || nx < WALL_LEFT() + 10 || nx > WALL_RIGHT() - 10) {
          this.growing = false;
          return;
        }

        let next = p.createVector(nx, ny);
        this.segs.push(new RootSegment(next.x, next.y, this, this.segmentCount++));
        this.dir = p.createVector(nx - pos.x, ny - pos.y).normalize();

        // Possibly branch roots if conditions met
        if (
          this.depth < MAX_ROOT_DEPTH &&
          this.segs.length > 5 &&
          this.segs.length - this.lastBranchAt > 8 &&
          totalRootSegments < MAX_ROOT_SEGMENTS * 0.8
        ) {
          if (p.random() < ROOT_BRANCH_CHANCE) {
            let angle1 = p.random(-p.PI / 3, p.PI / 3);
            let angle2 = p.random(-p.PI / 3, p.PI / 3);
            let branchDir1 = this.dir.copy().rotate(angle1);
            let branchDir2 = this.dir.copy().rotate(angle2);
            roots.push(new Root(this.tip().pos.x, this.tip().pos.y, branchDir1, this.depth + 1));
            if (p.random() < 0.6) {
              roots.push(new Root(this.tip().pos.x, this.tip().pos.y, branchDir2, this.depth + 1));
            }
            this.lastBranchAt = this.segs.length;
          }
        }
      }
    }

    // Class representing a nutrient particle in soil
    class Nutrient {
      constructor(x, y) {
        this.pos = p.createVector(x, y);
        this.vel = p.createVector(0, 0);
        this.life = 255; // Lifespan for fading out
        this.absorbed = false; // Whether nutrient is absorbed by root
        this.targetRoot = null; // Root segment absorbing this nutrient
        this.type = p.random() < 0.5 ? 'water' : 'mineral'; // Nutrient type
        this.size = p.random(2, 4);
        this.absorbSeg = null; // Segment where absorption started
        this.absorbTime = 0; // Time absorption started
      }

      // Update nutrient position and absorption state
      update() {
        if (this.absorbed) {
          this.life -= 8; // Fade out after absorption
          if (!this.absorbSeg && this.targetRoot) {
            this.absorbSeg = this.targetRoot;
            this.absorbTime = p.millis();
            // Trigger nutrient pulse animation from root to vine tip
            let vineTip = shoots.length > 0 ? shoots[0].tip().pos : null;
            if (vineTip) {
              nutrientPulses.push(new NutrientPulse(this.absorbSeg.pos.copy(), vineTip.copy(), this.type, this.absorbSeg));
            }
          }
          return this.life > 0;
        }

        // Find nearest root segment within range to absorb nutrient
        let minDist = Infinity;
        let nearestRoot = null;
        for (let root of roots) {
          for (let seg of root.segs) {
            let d = p5.Vector.dist(this.pos, seg.pos);
            if (d < minDist && d < 15) {
              minDist = d;
              nearestRoot = seg;
            }
          }
        }

        // Absorb nutrient if close enough to root
        if (nearestRoot && minDist < 8) {
          this.absorbed = true;
          this.targetRoot = nearestRoot;
          nearestRoot.lastAbsorption = p.millis();
          nearestRoot.absorbHighlight = 1.0;
        } else if (nearestRoot) {
          // Move nutrient towards root if nearby
          let force = p5.Vector.sub(nearestRoot.pos, this.pos);
          force.normalize();
          force.mult(0.1);
          this.vel.add(force);
        }

        // Add random movement and friction
        this.vel.add(p.random(-0.05, 0.05), p.random(-0.05, 0.05));
        this.vel.mult(0.95);
        this.pos.add(this.vel);

        // Constrain nutrient within soil boundaries
        this.pos.x = p.constrain(this.pos.x, WALL_LEFT() + 10, WALL_RIGHT() - 10);
        this.pos.y = p.constrain(this.pos.y, SOIL_TOP() + 10, p.height - 10);

        this.life -= 0.5; // Slowly fade nutrient over time
        return this.life > 0;
      }

      // Draw nutrient particle with color based on type and absorption state
      draw() {
        if (this.absorbed) {
          p.fill(255, 255, 0, this.life);
          p.stroke(255, 255, 120, this.life);
          p.strokeWeight(2);
        } else if (this.type === 'water') {
          p.fill(100, 180, 255, this.life);
          p.stroke(180, 220, 255, this.life);
          p.strokeWeight(2);
        } else {
          p.fill(255, 200, 60, this.life);
          p.stroke(255, 230, 120, this.life);
          p.strokeWeight(2);
        }
        p.ellipse(this.pos.x, this.pos.y, this.size * 2.2);
        p.noStroke();
      }
    }

    // Class representing a visual pulse showing nutrient flow from root to vine tip
    class NutrientPulse {
      constructor(start, end, type, rootSeg) {
        this.start = start.copy();
        this.end = end.copy();
        this.type = type;
        this.progress = 0; // Progress along path (0 to 1)
        this.done = false; // Whether pulse animation is finished
        this.path = []; // Array of points along path
        this.rootSeg = rootSeg;
        this.findPath();
        this.glow = 1.0; // Glow intensity for animation
      }
      // Find path from root to vine tip for pulse animation
      findPath() {
        let rootPath = [];
        let vinePath = [];
        let minRootDist = Infinity, minRootIdx = 0, minVineDist = Infinity, minVineIdx = 0;
        if (roots.length > 0 && shoots.length > 0) {
          let mainRoot = roots[0];
          let mainVine = shoots[0];
          // Find closest root segment to start point
          for (let i = 0; i < mainRoot.segs.length; i++) {
            let d = p5.Vector.dist(this.start, mainRoot.segs[i].pos);
            if (d < minRootDist) { minRootDist = d; minRootIdx = i; }
          }
          // Find closest vine segment to end point
          for (let i = 0; i < mainVine.segs.length; i++) {
            let d = p5.Vector.dist(this.end, mainVine.segs[i].pos);
            if (d < minVineDist) { minVineDist = d; minVineIdx = i; }
          }
          // Build path from root tip to base
          for (let i = minRootIdx; i >= 0; i--) rootPath.push(mainRoot.segs[i].pos.copy());
          // Build path from vine base to tip
          for (let i = 0; i <= minVineIdx; i++) vinePath.push(mainVine.segs[i].pos.copy());
          this.path = rootPath.concat(vinePath);
        } else {
          // Fallback direct path if no roots or shoots
          this.path = [this.start, this.end];
        }
      }
      // Update pulse animation progress and glow
      update() {
        this.progress += 0.022;
        if (this.progress >= 1) this.done = true;
        if (this.glow > 0) this.glow -= 0.04;
      }
      // Draw pulse as glowing ellipse moving along path
      draw() {
        if (this.path.length < 2) return;
        let idx = p.floor(this.progress * (this.path.length - 1));
        let frac = (this.progress * (this.path.length - 1)) % 1;
        let p1 = this.path[idx];
        let p2 = this.path[p.min(idx + 1, this.path.length - 1)];
        let x = p.lerp(p1.x, p2.x, frac);
        let y = p.lerp(p1.y, p2.y, frac);
        p.push();
        if (this.type === 'water') {
          p.fill(100, 200, 255, 230);
          p.stroke(180, 240, 255, 180);
        } else {
          p.fill(255, 230, 80, 240);
          p.stroke(255, 255, 180, 180);
        }
        p.strokeWeight(6 + 10 * this.glow);
        p.ellipse(x, y, 28 + 18 * this.glow, 28 + 18 * this.glow);
        p.noStroke();
        if (this.type === 'water') p.fill(120, 220, 255, 200);
        else p.fill(255, 240, 120, 200);
        p.ellipse(x, y, 18 + 8 * this.glow, 18 + 8 * this.glow);
        p.fill(255, 255, 255, 80);
        p.ellipse(x, y, 10 + 4 * this.glow, 10 + 4 * this.glow);
        p.pop();
      }
    }

    // Class representing a soil particle for visual texture
    class SoilParticle {
      constructor(x, y) {
        this.pos = p.createVector(x, y);
        this.size = p.random(1, 3);
        this.color = p.color(p.random(80, 120), p.random(50, 80), p.random(30, 50));
      }
      // Draw soil particle as small ellipse
      draw() {
        p.fill(this.color);
        p.noStroke();
        p.ellipse(this.pos.x, this.pos.y, this.size);
      }
    }

    // Draw soil texture to offscreen buffer for performance
    function drawSoilToBuffer() {
      soilGraphic.background(101, 67, 33);
      for (let i = 0; i < 1200; i++) {
        soilGraphic.fill(p.random(70, 130), p.random(40, 90), p.random(20, 60), p.random(100, 200));
        soilGraphic.noStroke();
        let x = p.random(0, WALL_W);
        let y = p.random(0, SOIL_HEIGHT);
        soilGraphic.ellipse(x, y, p.random(1, 4));
      }
      for (let i = 0; i < 80; i++) {
        soilGraphic.fill(40, 30, 20, 150);
        soilGraphic.noStroke();
        let x = p.random(0, WALL_W);
        let y = p.random(0, SOIL_HEIGHT);
        soilGraphic.ellipse(x, y, p.random(2, 6));
      }
    }

    // Draw wall texture to offscreen buffer for performance
    function drawWallToBuffer() {
      wallGraphic.background(235, 225, 210);
      wallGraphic.noStroke();
      wallGraphic.rect(0, 0, WALL_W, p.height - SOIL_HEIGHT);
      wallGraphic.stroke(200, 185, 165);
      wallGraphic.strokeWeight(2);
      let brickW = 45, brickH = 20;
      for (let y = 0; y < p.height - SOIL_HEIGHT; y += brickH) {
        for (let x = 0; x < WALL_W; x += brickW) {
          let offsetX = (Math.floor(y / brickH) % 2) * (brickW / 2);
          wallGraphic.fill(p.random(220, 240), p.random(200, 220), p.random(180, 200));
          wallGraphic.rect(x + offsetX, y, brickW - 2, brickH - 2, 2);
        }
      }
      for (let i = 0; i < 40; i++) {
        wallGraphic.fill(0, 0, 0, p.random(5, 15));
        wallGraphic.noStroke();
        let x = p.random(0, WALL_W);
        let y = p.random(0, p.height - SOIL_HEIGHT);
        wallGraphic.ellipse(x, y, p.random(1, 3));
      }
    }

    // Draw all obstacles (windows and pipes)
    function drawObstacles() {
      obstacles.forEach(ob => {
        if (ob.type === 'window') {
          // Draw window frame and glass
          p.fill(120, 100, 80);
          p.stroke(80, 60, 40);
          p.strokeWeight(4);
          p.rect(ob.x - ob.w / 2 - 5, ob.y - ob.h / 2 - 5, ob.w + 10, ob.h + 10, 6);
          p.fill(180, 200, 230, 200);
          p.stroke(140, 160, 190);
          p.strokeWeight(2);
          p.rect(ob.x - ob.w / 2, ob.y - ob.h / 2, ob.w, ob.h, 4);
          p.fill(255, 255, 255, 80);
          p.noStroke();
          p.rect(ob.x - ob.w / 2 + 5, ob.y - ob.h / 2 + 5, ob.w / 3, ob.h / 2, 2);
          p.stroke(100, 80, 60);
          p.strokeWeight(3);
          p.line(ob.x, ob.y - ob.h / 2, ob.x, ob.y + ob.h / 2);
          p.line(ob.x - ob.w / 2, ob.y, ob.x + ob.w / 2, ob.y);
        } else {
          // Draw pipe with shading and texture
          p.randomSeed(ob.seed);
          p.fill(0, 0, 0, 30);
          p.noStroke();
          p.ellipse(ob.x + 4, ob.y + 4, ob.r * 2.3);
          p.fill(140, 140, 140);
          p.stroke(100, 100, 100);
          p.strokeWeight(3);
          p.ellipse(ob.x, ob.y, ob.r * 2);
          p.fill(30, 30, 30);
          p.noStroke();
          p.ellipse(ob.x, ob.y, ob.r * 1.4);
          p.fill(80, 80, 80);
          p.noStroke();
          p.ellipse(ob.x, ob.y, ob.r * 1.2);
          p.fill(15, 15, 15);
          p.noStroke();
          p.ellipse(ob.x, ob.y, ob.r * 0.9);
          p.fill(180, 180, 180);
          p.noStroke();
          p.ellipse(ob.x - ob.r / 3, ob.y - ob.r / 3, ob.r * 1.2);
          p.stroke(80, 80, 80);
          p.strokeWeight(2);
          p.noFill();
          p.ellipse(ob.x, ob.y, ob.r * 1.8);
          p.ellipse(ob.x, ob.y, ob.r * 1.6);
          p.randomSeed();
        }
      });
    }

    // Draw all vine branches with leaves and growth tip highlight
    function drawVines() {
      shoots.forEach(branch => {
        // Set stroke color based on branch depth for shading
        let greenBase = 45 + branch.depth * 15;
        let greenVariation = 120 + 25 * branch.depth;
        p.stroke(greenBase, greenVariation, 60 + branch.depth * 10);
        p.strokeWeight(SEG_RAD * (2.8 - branch.depth * 0.6));
        p.noFill();
        p.beginShape();
        if (branch.segs.length > 2) {
          p.curveVertex(branch.segs[0].pos.x, branch.segs[0].pos.y);
        }
        for (let seg of branch.segs) {
          p.curveVertex(seg.pos.x, seg.pos.y);
        }
        if (branch.segs.length > 2) {
          let last = branch.segs[branch.segs.length - 1];
          p.curveVertex(last.pos.x, last.pos.y);
        }
        p.endShape();

        // Draw leaves on segments that have them
        branch.segs.forEach(seg => {
          if (seg.hasLeaf) {
            drawLeaf(seg.pos.x, seg.pos.y, seg.leafAngle, seg.leafSize, seg.leafType, branch.depth);
          }
        });

        // Highlight growing tip with glowing ellipses
        if (branch.growing) {
          let tip = branch.tip().pos;
          p.noStroke();
          p.fill(70, 200, 90, 150);
          p.ellipse(tip.x, tip.y, SEG_RAD * 3);
          p.fill(90, 255, 110, 100);
          p.ellipse(tip.x, tip.y, SEG_RAD * 2);
        }
      });
    }

    // Draw all root branches with hairs and absorption highlights
    function drawRoots() {
      if (!showRoots) return;
      roots.forEach(root => {
        // Outer outline for contrast
        let brownBase = 120 + root.depth * 10;
        let brownVariation = 80 + root.depth * 15;
        p.stroke(40, 30, 10, 180);
        p.strokeWeight(SEG_RAD * (4.2 - root.depth * 0.7));
        p.noFill();
        p.beginShape();
        if (root.segs.length > 2) {
          p.curveVertex(root.segs[0].pos.x, root.segs[0].pos.y);
        }
        for (let seg of root.segs) {
          p.curveVertex(seg.pos.x, seg.pos.y);
        }
        if (root.segs.length > 2) {
          let last = root.segs[root.segs.length - 1];
          p.curveVertex(last.pos.x, last.pos.y);
        }
        p.endShape();

        // Main root color stroke
        p.stroke(brownBase, brownVariation, 33 + root.depth * 8, 255);
        p.strokeWeight(SEG_RAD * (2.8 - root.depth * 0.6));
        p.noFill();
        p.beginShape();
        if (root.segs.length > 2) {
          p.curveVertex(root.segs[0].pos.x, root.segs[0].pos.y);
        }
        for (let seg of root.segs) {
          p.curveVertex(seg.pos.x, seg.pos.y);
        }
        if (root.segs.length > 2) {
          let last = root.segs[root.segs.length - 1];
          p.curveVertex(last.pos.x, last.pos.y);
        }
        p.endShape();

        // Draw root hairs and absorption highlights on each segment
        root.segs.forEach(seg => {
          // Highlight absorption with glowing ellipse
          if (seg.absorbHighlight > 0.01) {
            let alpha = 180 * seg.absorbHighlight;
            p.fill(255, 255, 80, alpha);
            p.noStroke();
            p.ellipse(seg.pos.x, seg.pos.y, 22 + 10 * seg.absorbHighlight);
            seg.absorbHighlight *= 0.92; // Fade highlight
          }
          // Show recent absorption with yellow ellipse
          if (p.millis() - seg.lastAbsorption < 2000) {
            p.noStroke();
            p.fill(255, 255, 0, 120);
            p.ellipse(seg.pos.x, seg.pos.y, 18);
          }
          // Draw root hairs randomly
          if (p.random() < 0.12) {
            p.stroke(139, 90, 43, 150);
            p.strokeWeight(0.7);
            for (let i = 0; i < 4; i++) {
              let angle = p.random(p.TWO_PI);
              let length = p.random(4, 10);
              let x2 = seg.pos.x + p.cos(angle) * length;
              let y2 = seg.pos.y + p.sin(angle) * length;
              p.line(seg.pos.x, seg.pos.y, x2, y2);
            }
          }
        });

        // Highlight growing root tip
        if (root.growing) {
          let tip = root.tip().pos;
          p.noStroke();
          p.fill(139, 90, 43, 150);
          p.ellipse(tip.x, tip.y, SEG_RAD * 3);
        }
      });
    }

    // Draw nutrient flow pulses
    function drawNutrientFlow() {
      if (!showNutrients) return;
      for (let pulse of nutrientPulses) pulse.draw();
    }

    // Draw a leaf at given position with rotation, size, and type
    function drawLeaf(x, y, angle, size, type, depth) {
      p.push();
      p.translate(x, y);
      p.rotate(angle);
      p.scale(size);
      let alpha = 200 - depth * 30;
      let leafGreen = 50 + depth * 20;
      if (type === 'small') {
        p.fill(leafGreen, 160, 70, alpha);
        p.noStroke();
        p.ellipse(8, 0, 12, 6);
        p.ellipse(-8, 0, 12, 6);
      } else {
        p.fill(leafGreen, 150, 70, alpha);
        p.noStroke();
        p.ellipse(15, -3, 18, 12);
        p.ellipse(-15, 3, 18, 12);
        p.ellipse(0, -8, 14, 8);
        p.ellipse(0, 8, 14, 8);
        p.stroke(leafGreen - 20, 120, 50, alpha * 0.8);
        p.strokeWeight(0.8);
        p.line(-12, 0, 12, 0);
        p.line(0, -6, 0, 6);
        p.line(-8, -3, 8, 3);
      }
      p.pop();
    }

    // Draw the seed at the base of the plant
    function drawSeed() {
      // Draw seed as a brown oval with some texture
      let cx = p.width * WALL_X;
      let cy = SOIL_TOP() + 5;
      p.push();
      p.translate(cx, cy);
      p.noStroke();
      p.fill(101, 67, 33);
      p.ellipse(0, 0, 30, 20);
      p.fill(80, 50, 20);
      p.ellipse(-5, 0, 10, 15);
      p.ellipse(5, 0, 10, 15);
      p.pop();
    }

    // p5.js sketch setup function
    p.setup = () => {
      const canvas = p.createCanvas(p.windowWidth, p.windowHeight);
      canvas.parent('canvas-container');
      p.pixelDensity(1);
      p.frameRate(30);

      // Create offscreen graphics buffers for wall and soil textures
      wallGraphic = p.createGraphics(WALL_W, p.height - SOIL_HEIGHT);
      soilGraphic = p.createGraphics(WALL_W, SOIL_HEIGHT);

      // Draw static textures once
      drawWallToBuffer();
      drawSoilToBuffer();

      // Create soil particles for visual effect
      for (let i = 0; i < 350; i++) {
        let x = p.random(WALL_LEFT(), WALL_RIGHT());
        let y = p.random(SOIL_TOP(), p.height);
        soilParticles.push(new SoilParticle(x, y));
      }

      // Initialize simulation state
      resetSim();

      // Setup UI button event handlers
      document.getElementById('reset-btn').onclick = resetSim;
      document.getElementById('toggle-nutrients').onclick = () => {
        nutrientFlow = !nutrientFlow;
      };
    };

    // Handle window resize events
    p.windowResized = () => {
      p.resizeCanvas(p.windowWidth, p.windowHeight);
      wallGraphic = p.createGraphics(WALL_W, p.height - SOIL_HEIGHT);
      soilGraphic = p.createGraphics(WALL_W, SOIL_HEIGHT);
      drawWallToBuffer();
      drawSoilToBuffer();
    };

    // Main draw loop called by p5.js
    p.draw = () => {
      p.background(245, 250, 245);

      // Draw wall and soil textures
      p.image(wallGraphic, WALL_LEFT(), 0);
      p.image(soilGraphic, WALL_LEFT(), SOIL_TOP());

      // Draw soil particles if enabled
      if (showSoilParticles) {
        soilParticles.forEach(particle => particle.draw());
      }

      // Draw seed at base
      drawSeed();

      // Grow roots and vines at their respective intervals
      if (p.millis() - lastRootGrow > ROOT_GROW_INTERVAL) {
        roots.forEach(r => r.stepGrowth());
        lastRootGrow = p.millis();
      }
      if (p.millis() - lastGrow > GROW_INTERVAL) {
        shoots.forEach(b => b.stepGrowth());
        lastGrow = p.millis();
      }

      // Spawn nutrients periodically if nutrient flow enabled
      if (nutrientFlow && p.millis() - lastNutrientSpawn > 200) {
        if (nutrients.length < 120) {
          let x = p.random(WALL_LEFT() + 10, WALL_RIGHT() - 10);
          let y = p.random(SOIL_TOP() + 20, p.height - 20);
          nutrients.push(new Nutrient(x, y));
        }
        lastNutrientSpawn = p.millis();
      }

      // Update nutrients and nutrient pulses, removing finished ones
      nutrients = nutrients.filter(nutrient => nutrient.update());
      nutrientPulses = nutrientPulses.filter(pulse => { pulse.update(); return !pulse.done; });

      // Draw obstacles, roots, vines, and nutrient flow
      drawObstacles();
      drawRoots();
      drawVines();
      drawNutrientFlow();

      // Draw nutrient particles if enabled
      if (showNutrients) {
        nutrients.forEach(nutrient => nutrient.draw());
      }

      // Draw soil surface line
      p.stroke(101, 67, 33);
      p.strokeWeight(3);
      p.line(WALL_LEFT(), SOIL_TOP(), WALL_RIGHT(), SOIL_TOP());

      // Display stats on screen
      p.fill(0);
      p.textSize(12);
      let totalSegs = shoots.reduce((sum, shoot) => sum + shoot.segs.length, 0);
      let totalRootSegs = roots.reduce((sum, root) => sum + root.segs.length, 0);
      p.text(`Vine Segments: ${totalSegs}/${MAX_SEGMENTS}`, p.width - 220, 20);
      p.text(`Root Segments: ${totalRootSegs}/${MAX_ROOT_SEGMENTS}`, p.width - 220, 35);
      p.text(`Nutrients: ${nutrients.length}`, p.width - 220, 50);
    };

    // Handle mouse press events for dragging or adding obstacles
    p.mousePressed = () => {
      // Check if clicking on an obstacle to drag
      for (const ob of obstacles) {
        if (ob.type === 'window' && ob.contains(p.mouseX, p.mouseY)) {
          dragging = ob; dragDX = ob.x - p.mouseX; dragDY = ob.y - p.mouseY; return;
        }
        if (ob.type === 'pipe' && p.dist(p.mouseX, p.mouseY, ob.x, ob.y) < ob.r + 10) {
          dragging = ob; dragDX = ob.x - p.mouseX; dragDY = ob.y - p.mouseY; return;
        }
      }
      // Detect single vs double click to add pipe or window
      let currentTime = p.millis();
      if (currentTime - lastClickTime < 300) {
        if (clickTimeout) {
          clearTimeout(clickTimeout);
          clickTimeout = null;
        }
        let x = p.constrain(p.mouseX, WALL_LEFT() + 40, WALL_RIGHT() - 40);
        obstacles.push(new WindowOb(x, p.mouseY));
      } else {
        clickTimeout = setTimeout(() => {
          let x = p.constrain(p.mouseX, WALL_LEFT() + 30, WALL_RIGHT() - 30);
          obstacles.push(new PipeOb(x, p.mouseY));
          clickTimeout = null;
        }, 300);
      }
      lastClickTime = currentTime;
    };

    // Handle dragging obstacles with mouse
    p.mouseDragged = () => {
      if (dragging) {
        dragging.x = p.constrain(p.mouseX + dragDX, WALL_LEFT() + 40, WALL_RIGHT() - 40);
        dragging.y = p.constrain(p.mouseY + dragDY, 60, SOIL_TOP() - 60);
      }
    };

    // Stop dragging on mouse release
    p.mouseReleased = () => {
      dragging = null;
    };

    // Reset simulation to initial state
    function resetSim() {
      let cx = p.width * WALL_X;
      // Initialize obstacles with some windows and pipes
      obstacles = [
        new WindowOb(cx + 100, p.height / 2 - 120, 80, 55),
        new PipeOb(cx - 80, p.height / 2 - 200, 28),
        new WindowOb(cx + 120, p.height / 2 - 280, 70, 50)
      ];
      shoots = [];
      roots = [];
      nutrients = [];
      nutrientPulses = [];
      let baseY = SOIL_TOP();
      let rootY = SOIL_TOP() + 10;

      // Create initial roots and start growing
      roots.push(new Root(cx, rootY, p.createVector(0, 1), 0));
      roots.push(new Root(cx - 20, rootY, p.createVector(-0.3, 0.95), 0));
      roots.push(new Root(cx + 20, rootY, p.createVector(0.3, 0.95), 0));
      roots.push(new Root(cx - 40, rootY, p.createVector(-0.6, 0.8), 1));
      roots.push(new Root(cx + 40, rootY, p.createVector(0.6, 0.8), 1));
      roots.forEach(r => r.growing = true);

      // Create initial shoots and start growing
      shoots.push(new Shoot(cx, baseY, p.createVector(0, -1), 0));
      shoots.push(new Shoot(cx - 25, baseY, p.createVector(-0.15, -0.99), 1));
      shoots.push(new Shoot(cx + 25, baseY, p.createVector(0.15, -0.99), 1));
      shoots.forEach(s => s.growing = true);

      // Reset timers
      lastGrow = p.millis();
      lastRootGrow = p.millis();
      lastNutrientSpawn = p.millis();
    }
  };

  // Create p5 instance
  new p5(sketch);
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Optical Fiber Simulation - 90° Bend</title>
    <!-- Styling -->
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            margin-bottom: 10px;
            color: #4a9eff;
        }
        .info {
            margin-bottom: 10px;
            text-align: center;
        }
        .analysis-box {
            background: #222e3a;
            border: 1px solid #4a9eff;
            border-radius: 8px;
            padding: 10px 18px;
            margin-bottom: 18px;
            font-size: 15px;
            color: #bfe2ff;
            min-width: 320px;
            text-align: left;
            box-shadow: 0 2px 8px #0004;
        }
        #canvas-container {
            border: 2px solid #333;
            border-radius: 10px;
            background-color: #000;
            position: relative;
        }
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        button {
            background-color: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 0 10px;
        }
        button:hover {
            background-color: #357abd;
        }
        button:active {
            background-color: #2a5f8f;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "p5": "https://esm.sh/p5@1.4.0"
            }
        }
    </script>
</head>
<body>
    <h1>2D Optical Fiber Simulation</h1>
    <div class="info">
        <p>90° Bend with Enhanced Total Internal Reflection & Bend Wall Dissipation</p>
    </div>
    <div class="analysis-box" id="analysis-box"></div>
    <div id="canvas-container"></div>
    <div class="controls">
        <button onclick="resetSimulation()">Reset Simulation</button>
    </div>
    <script type="module">
        import p5 from "p5";

        // Simulation state variables
        let fiber; // The optical fiber object
        let lightRays = []; // Array of all light rays in the simulation
        let reflectionPoints = []; // Stores points where rays reflect
        let radiationLosses = []; // Stores dissipating rays (escaped energy)
        let animationTime = 0; // Animation frame counter
        let raySpawnTimer = 0; // Not used, but can be for timed ray spawning

        // Statistics counters
        let raysLaunched = 0;
        let raysTransmitted = 0;
        let raysLost = 0;
        let totalReflections = 0;
        let totalBendReflections = 0;
        let raysFadedAtBend = 0;
        let bendWallTouches = 0;

        let finalIntensities = []; // Stores final intensity of each ray
        let simulationStopped = false; // Whether simulation is paused/stopped

        // Class representing the optical fiber geometry and boundaries
        class OpticalFiber {
            constructor() {
                this.coreRadius = 25;      // Core radius (pixels)
                this.claddingRadius = 35;  // Cladding radius (pixels)
                this.bendRadius = 80;      // Bend arc radius (pixels)
                this.straightLength = 150; // Length of straight sections (pixels)
            }

            // Draws the entire fiber (mesh, cladding, core, ends)
            draw(p) {
                this.drawMesh(p);
                this.drawCladding(p);
                this.drawCore(p);
                this.drawEndMasks(p);
                this.drawOpenEnds(p);
            }

            // Draws the cladding (outer layer)
            drawCladding(p) {
                p.stroke(100, 100, 150);
                p.strokeWeight(this.claddingRadius * 2);
                p.noFill();
                // Horizontal section
                p.line(50, 300, 200, 300);
                // Bend (quarter circle)
                p.arc(200, 220, this.bendRadius * 2, this.bendRadius * 2, 0, Math.PI / 2);
                // Vertical section
                p.line(280, 220, 280, 70);
            }

            // Draws the core (inner light-carrying region)
            drawCore(p) {
                p.stroke(100, 180, 255);
                p.strokeWeight(this.coreRadius * 2);
                p.line(50, 300, 200, 300);
                p.arc(200, 220, this.bendRadius * 2, this.bendRadius * 2, 0, Math.PI / 2);
                p.line(280, 220, 280, 70);
            }

            // Draws a mesh pattern for visual effect
            drawMesh(p) {
                p.stroke(80, 80, 120, 100);
                p.strokeWeight(1);
                // Horizontal mesh
                for (let x = 45; x <= 205; x += 8) {
                    for (let y = 260; y <= 340; y += 8) {
                        if (Math.abs(y - 300) > this.claddingRadius + 5 && Math.abs(y - 300) < this.claddingRadius + 15) {
                            p.line(x, y, x + 4, y + 4);
                            p.line(x + 4, y, x, y + 4);
                        }
                    }
                }
                // Vertical mesh
                for (let x = 240; x <= 320; x += 8) {
                    for (let y = 65; y <= 225; y += 8) {
                        if (Math.abs(x - 280) > this.claddingRadius + 5 && Math.abs(x - 280) < this.claddingRadius + 15) {
                            p.line(x, y, x + 4, y + 4);
                            p.line(x + 4, y, x, y + 4);
                        }
                    }
                }
                // Bend mesh
                for (let angle = 0; angle <= Math.PI / 2; angle += 0.2) {
                    let innerR = this.bendRadius + this.claddingRadius + 5;
                    let outerR = this.bendRadius + this.claddingRadius + 15;
                    for (let r = innerR; r <= outerR; r += 8) {
                        let x1 = 200 + r * Math.cos(angle);
                        let y1 = 220 + r * Math.sin(angle);
                        let x2 = x1 + 4 * Math.cos(angle + Math.PI/4);
                        let y2 = y1 + 4 * Math.sin(angle + Math.PI/4);
                        p.line(x1, y1, x2, y2);
                        let x3 = x1 + 4 * Math.cos(angle - Math.PI/4);
                        let y3 = y1 + 4 * Math.sin(angle - Math.PI/4);
                        p.line(x1, y1, x3, y3);
                    }
                }
            }

            // Draws the open ends of the fiber
            drawOpenEnds(p) {
                // Left end
                p.stroke(100, 100, 150);
                p.strokeWeight(3);
                p.line(50, 300 - this.claddingRadius, 50, 300 + this.claddingRadius);
                p.stroke(100, 180, 255);
                p.strokeWeight(2);
                p.line(50, 300 - this.coreRadius, 50, 300 + this.coreRadius);
                // Top end
                p.stroke(100, 100, 150);
                p.strokeWeight(3);
                p.line(280 - this.claddingRadius, 70, 280 + this.claddingRadius, 70);
                p.stroke(100, 180, 255);
                p.strokeWeight(2);
                p.line(280 - this.coreRadius, 70, 280 + this.coreRadius, 70);
            }

            // Draws black rectangles to mask the ends for a clean look
            drawEndMasks(p) {
                p.noStroke();
                p.fill(0);
                p.rect(10, 300 - this.claddingRadius - 2, 40, this.claddingRadius * 2 + 4);
                p.rect(275 - this.claddingRadius - 2, 35, this.claddingRadius * 2 + 4, 22);
            }

            // Returns the distance to the nearest core boundary and the normal vector at that point
            getDistanceToCoreBoundary(x, y) {
                let minDist = Infinity;
                let normal = null;
                let isBend = false;
                // Horizontal section boundaries
                if (x >= 50 && x <= 200) {
                    let distTop = Math.abs(y - (300 - this.coreRadius));
                    let distBottom = Math.abs(y - (300 + this.coreRadius));
                    if (distTop < minDist && y <= 300) {
                        minDist = distTop;
                        normal = { x: 0, y: -1 };
                    }
                    if (distBottom < minDist && y >= 300) {
                        minDist = distBottom;
                        normal = { x: 0, y: 1 };
                    }
                }
                // Vertical section boundaries
                if (y >= 70 && y <= 220) {
                    let distLeft = Math.abs(x - (280 - this.coreRadius));
                    let distRight = Math.abs(x - (280 + this.coreRadius));
                    if (distLeft < minDist && x <= 280) {
                        minDist = distLeft;
                        normal = { x: -1, y: 0 };
                    }
                    if (distRight < minDist && x >= 280) {
                        minDist = distRight;
                        normal = { x: 1, y: 0 };
                    }
                }
                // Bend boundaries (arc)
                let dx = x - 200;
                let dy = y - 220;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx);
                if (angle >= 0 && angle <= Math.PI / 2) {
                    let distOuter = Math.abs(distance - (this.bendRadius + this.coreRadius));
                    if (distOuter < minDist && distance > this.bendRadius) {
                        minDist = distOuter;
                        normal = { x: dx / distance, y: dy / distance };
                        isBend = true;
                    }
                    let distInner = Math.abs(distance - (this.bendRadius - this.coreRadius));
                    if (distInner < minDist && distance < this.bendRadius) {
                        minDist = distInner;
                        normal = { x: -dx / distance, y: -dy / distance };
                        isBend = true;
                    }
                }
                return { distance: minDist, normal: normal, isBend: isBend };
            }

            // Checks if a point is inside the core region
            isInsideCore(x, y) {
                if (x >= 50 && x <= 200 && Math.abs(y - 300) <= this.coreRadius) return true;
                if (Math.abs(x - 280) <= this.coreRadius && y >= 70 && y <= 220) return true;
                let dx = x - 200;
                let dy = y - 220;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx);
                if (angle >= 0 && angle <= Math.PI / 2 &&
                    distance >= this.bendRadius - this.coreRadius &&
                    distance <= this.bendRadius + this.coreRadius) return true;
                return false;
            }

            // Checks if a point is in the bend region (arc)
            isInBendRegion(x, y) {
                let dx = x - 200;
                let dy = y - 220;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let angle = Math.atan2(dy, dx);
                return (angle >= 0 && angle <= Math.PI / 2 &&
                        distance >= this.bendRadius - this.coreRadius &&
                        distance <= this.bendRadius + this.coreRadius);
            }
        }

        // Class representing a single light ray
        class LightRay {
            constructor(startY = 300, angle = 0, id = 0) {
                this.position = { x: 30, y: startY }; // Start at left end
                this.direction = { x: Math.cos(angle), y: Math.sin(angle) }; // Initial direction
                this.speed = 1.0; // Step size per frame
                this.active = true; // Whether the ray is still propagating
                this.path = [{ ...this.position }]; // Stores the path for drawing
                this.reflectionCount = 0; // Total reflections
                this.bendReflectionCount = 0; // Reflections at bend wall
                this.intensity = 1.0; // Current intensity (fades with dissipation)
                this.id = id; // Ray identifier
                this.hasExited = false; // True if ray exited at the top
                this.hasEscaped = false; // True if ray escaped the core
                this.hasFadedAtBend = false; // True if ray has faded on first bend entry
                this.stepsSinceReflection = 0; // Used to avoid double-counting reflections
                this.hasLeftBend = false; // Not used, but can be for more logic
            }

            // Updates the ray's position and handles reflections, dissipation, and exit
            update(p) {
                if (!this.active) return;

                let totalStep = this.speed;
                let subStep = 0.1; // Use small steps for accurate boundary detection
                let steps = Math.ceil(totalStep / subStep);

                for (let s = 0; s < steps && this.active; s++) {
                    let moveStep = Math.min(subStep, totalStep - s * subStep);
                    let nextX = this.position.x + this.direction.x * moveStep;
                    let nextY = this.position.y + this.direction.y * moveStep;

                    // Fade on first entry to bend region
                    if (!this.hasFadedAtBend && fiber.isInBendRegion(nextX, nextY)) {
                        this.intensity *= 0.93; // 7% fade
                        this.hasFadedAtBend = true;
                        raysFadedAtBend++;
                    }

                    // Check for boundary collision and handle reflection or escape
                    let boundaryInfo = fiber.getDistanceToCoreBoundary(nextX, nextY);
                    if (boundaryInfo.distance < 0.8 && this.stepsSinceReflection > 1) {
                        let incVec = { x: this.direction.x, y: this.direction.y };
                        let normal = boundaryInfo.normal;
                        if (normal) {
                            // Calculate angle of incidence and check for total internal reflection
                            let dot = incVec.x * normal.x + incVec.y * normal.y;
                            dot = Math.max(-1, Math.min(1, dot)); // Clamp for safety
                            let angleIncidence = Math.acos(-dot);
                            let n1 = 1.46, n2 = 1.45;
                            let criticalAngle = Math.asin(n2 / n1);
                            if (angleIncidence >= criticalAngle) {
                                // Fade every time ray touches the bend wall
                                if (boundaryInfo.isBend) {
                                    this.intensity *= 0.93; // 7% fade
                                    this.bendReflectionCount++;
                                    totalBendReflections++;
                                    bendWallTouches++;
                                }
                                this.handleReflection(normal, p, boundaryInfo.isBend);
                                this.reflectionCount++;
                                totalReflections++;
                                this.stepsSinceReflection = 0;
                                continue;
                            } else {
                                // Ray escapes the core (dissipates)
                                this.active = false;
                                this.hasEscaped = true;
                                this.createRadiationLoss();
                                raysLost++;
                                finalIntensities.push(this.intensity);
                                return;
                            }
                        }
                    } else {
                        // No reflection, just move forward
                        this.position.x = nextX;
                        this.position.y = nextY;
                        this.stepsSinceReflection++;
                    }
                    // Store path for drawing
                    this.path.push({ ...this.position });
                    if (this.path.length > 150) {
                        this.path.shift();
                    }
                    // Check for exit at the top end
                    if (this.position.y < 70 && Math.abs(this.position.x - 280) < 30) {
                        this.active = false;
                        this.hasExited = true;
                        raysTransmitted++;
                        finalIntensities.push(this.intensity);
                        return;
                    }
                    // Check for out-of-bounds (lost ray)
                    if (this.position.x > 400 || this.position.y > 400 ||
                        this.position.x < 0 || this.position.y < 0) {
                        this.active = false;
                        this.hasEscaped = true;
                        raysLost++;
                        finalIntensities.push(this.intensity);
                        return;
                    }
                }
            }

            // Handles the reflection of the ray at a boundary
            handleReflection(normal, p, isBend) {
                if (!normal) return;
                // Reflect the direction vector
                let dot = 2 * (this.direction.x * normal.x + this.direction.y * normal.y);
                this.direction.x -= dot * normal.x;
                this.direction.y -= dot * normal.y;
                // Normalize direction
                let magnitude = Math.sqrt(this.direction.x * this.direction.x + this.direction.y * this.direction.y);
                this.direction.x /= magnitude;
                this.direction.y /= magnitude;
                // Store reflection point for drawing
                reflectionPoints.push({
                    x: this.position.x,
                    y: this.position.y,
                    time: p.millis(),
                    intensity: this.intensity,
                    rayId: this.id,
                    isBend: isBend
                });
                // Move slightly away from the wall to avoid repeated reflections
                this.position.x -= normal.x * 3;
                this.position.y -= normal.y * 3;
            }

            // Creates a dissipating "radiation loss" effect when the ray escapes
            createRadiationLoss() {
                radiationLosses.push({
                    position: { x: this.position.x, y: this.position.y },
                    intensity: this.intensity * 0.8,
                    life: 25,      // Number of frames to show the dissipation
                    maxLife: 25,
                });
            }

            // Draws the ray's path and current position
            draw(p) {
                if (this.path.length < 2) return;
                p.strokeWeight(3);
                p.noFill();
                // Draw the path as a fading line
                for (let i = 1; i < this.path.length; i++) {
                    let alpha = p.map(i, 0, this.path.length - 1, 10, 255) * this.intensity;
                    if (this.id === 1) {
                        p.stroke(100, 150, 255, alpha); // Blue
                    } else {
                        p.stroke(255, 100, 100, alpha); // Red
                    }
                    p.line(this.path[i-1].x, this.path[i-1].y, this.path[i].x, this.path[i].y);
                }
                // Draw the ray "head"
                if (this.active) {
                    if (this.id === 1) {
                        p.fill(100, 150, 255, 255 * this.intensity);
                    } else {
                        p.fill(255, 100, 100, 255 * this.intensity);
                    }
                    p.noStroke();
                    p.ellipse(this.position.x, this.position.y, 8, 8);
                    // Draw a faint glow
                    for (let r = 10; r < 25; r += 5) {
                        if (this.id === 1) {
                            p.fill(100, 150, 255, 10 * this.intensity);
                        } else {
                            p.fill(255, 100, 100, 10 * this.intensity);
                        }
                        p.ellipse(this.position.x, this.position.y, r, r);
                    }
                }
            }
        }

        // Main p5.js sketch
        const sketch = (p) => {
            p.setup = () => {
                let canvas = p.createCanvas(400, 400);
                canvas.parent('canvas-container');
                fiber = new OpticalFiber();
                simulationStopped = false;
                launchRays();
            };
            p.draw = () => {
                p.background(0);
                fiber.draw(p);

                if (simulationStopped) {
                    updateAnalysisBox();
                    return;
                }

                // Update and draw all rays
                for (let ray of lightRays) {
                    ray.update(p);
                    ray.draw(p);
                }

                // Draw and update dissipating (escaped) rays
                for (let i = radiationLosses.length - 1; i >= 0; i--) {
                    let radiation = radiationLosses[i];
                    radiation.life--;
                    if (radiation.life <= 0) {
                        radiationLosses.splice(i, 1);
                        continue;
                    }
                    let alpha = p.map(radiation.life, 0, radiation.maxLife, 0, 150) * radiation.intensity;
                    p.noStroke();
                    // Draw dissipating glow
                    for (let r = 8; r < 20; r += 3) {
                        p.fill(255, 255, 180, alpha * 0.15);
                        p.ellipse(radiation.position.x, radiation.position.y, r, r);
                    }
                    p.fill(255, 255, 180, alpha * 0.6);
                    p.ellipse(radiation.position.x, radiation.position.y, 6, 6);
                }

                // Draw reflection points (fading effect)
                for (let i = reflectionPoints.length - 1; i >= 0; i--) {
                    let point = reflectionPoints[i];
                    let age = p.millis() - point.time;
                    let alpha = p.map(age, 0, 1000, 255, 0) * point.intensity;
                    if (alpha <= 0) {
                        reflectionPoints.splice(i, 1);
                        continue;
                    }
                    if (point.isBend) {
                        p.fill(255, 220, 80, alpha);
                    } else {
                        p.fill(255, 255, 150, alpha);
                    }
                    p.noStroke();
                    p.ellipse(point.x, point.y, 12, 12);
                    for (let r = 14; r < 24; r += 3) {
                        p.fill(point.isBend ? 255 : 255, point.isBend ? 220 : 255, 150, alpha * 0.2);
                        p.ellipse(point.x, point.y, r, r);
                    }
                }
                animationTime++;
                updateAnalysisBox();

                // Stop simulation if all rays are inactive
                if (lightRays.every(ray => !ray.active)) {
                    simulationStopped = true;
                    p.noLoop();
                }
            };
        };

        // Launches the initial rays into the fiber
        function launchRays(n = 2) {
            if (n === 2) {
                // Reset all statistics
                raysLaunched = 0;
                raysTransmitted = 0;
                raysLost = 0;
                totalReflections = 0;
                totalBendReflections = 0;
                raysFadedAtBend = 0;
                bendWallTouches = 0;
                finalIntensities = [];
            }
            // Two rays: one blue, one red, with different angles
            let angles = [0.70, -0.70];
            let yPositions = [280, 320];
            for (let i = 0; i < n; i++) {
                lightRays.push(new LightRay(yPositions[i], angles[i], i + 1));
                raysLaunched++;
            }
        }

        // Updates the informational analysis box in real time
        function updateAnalysisBox() {
            let box = document.getElementById('analysis-box');
            let eff = raysLaunched > 0 ? (raysTransmitted / raysLaunched * 100).toFixed(1) : "0";
            let avgRef = raysLaunched > 0 ? (totalReflections / raysLaunched).toFixed(1) : "0";
            let avgBendRef = raysLaunched > 0 ? (totalBendReflections / raysLaunched).toFixed(1) : "0";
            let avgDiss = "0";
            if (raysLaunched > 0 && finalIntensities.length > 0) {
                let sumFinal = finalIntensities.reduce((a, b) => a + b, 0);
                avgDiss = (100 * (1 - sumFinal / finalIntensities.length)).toFixed(1);
            }
            // Show the number of currently dissipating rays in real time
            let dissipatingCount = radiationLosses.length;
            box.innerHTML = `
                <b>Enhanced Ray Analysis:</b><br>
                Rays Launched: <b>${raysLaunched}</b><br>
                Rays Transmitted: <b>${raysTransmitted}</b><br>
                Rays Lost: <b>${raysLost}</b><br>
                <span style="color:#ffe066">Currently Dissipating: <b>${dissipatingCount}</b></span><br>
                Transmission Efficiency: <b>${eff}%</b><br>
                Total Reflections: <b>${totalReflections}</b> (avg: <b>${avgRef}</b> per ray)<br>
                <span style="color:#ffe066">Bend-wall Reflections: <b>${totalBendReflections}</b> (avg: ${avgBendRef})</span><br>
                <span style="color:#ffe066">Bend-wall Touches: <b>${bendWallTouches}</b></span><br>
                <span style="color:#ffe066">Rays Faded at Bend Entry: <b>${raysFadedAtBend}</b></span><br>
                <span style="color:#ffe066">Avg. Bend Dissipation: <b>${avgDiss}%</b></span><br>
            `;
        }

        // Resets the simulation to its initial state
        window.resetSimulation = function() {
            lightRays = [];
            reflectionPoints = [];
            radiationLosses = [];
            animationTime = 0;
            raySpawnTimer = 0;
            raysLaunched = 0;
            raysTransmitted = 0;
            raysLost = 0;
            totalReflections = 0;
            totalBendReflections = 0;
            raysFadedAtBend = 0;
            bendWallTouches = 0;
            finalIntensities = [];
            simulationStopped = false;
            launchRays();
            if (window.p5Instance) window.p5Instance.loop();
        };

        // Start the p5.js sketch
        window.p5Instance = new p5(sketch);
    </script>
</body>
</html>
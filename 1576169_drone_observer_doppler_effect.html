<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>2D Doppler Effect Simulation</title>
  <!-- Importing Libraries -->
  <script type="importmap">
  {
    "imports": {
      "p5": "https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"
    }
  }
  </script>
  <!-- Styling -->
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background: #f0f0f0;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    h1 {
      color: #333;
      margin-bottom: 10px;
    }
    .info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      max-width: 900px;
      text-align: center;
    }
    .controls {
      margin: 20px 0 10px 0;
      display: flex;
      align-items: center;
      gap: 20px;
    }
    .slider-group {
      display: flex;
      align-items: center;
      gap: 10px;
      background: #fff;
      padding: 8px 16px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.08);
    }
    .slider-group label {
      font-size: 15px;
      color: #222;
    }
    .slider-group input[type=range] {
      width: 220px;
      accent-color: #4CAF50;
    }
    .slider-value {
      font-weight: bold;
      color: #1976d2;
      min-width: 60px;
      text-align: right;
      font-size: 15px;
    }
    button {
      background: #4CAF50;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    #canvas-container {
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <h1>2D Doppler Effect Simulation - Fixed & Optimized</h1>

  <div class="info">
    <p><strong>Watch the aircraft fly past the observer!</strong> The frequency increases gradually as the aircraft approaches, peaks when overhead, and decreases smoothly after the aircraft passes the observer position.</p>
  </div>

  <div class="controls">
    <div class="slider-group">
      <label for="speedSlider">Aircraft Speed:</label>
      <input type="range" id="speedSlider" min="10" max="90" value="60" step="1">
      <span class="slider-value" id="speedValue">216.0 km/h</span>
    </div>
    <button id="resetBtn">Reset Simulation</button>
  </div>

  <div id="canvas-container"></div>
  <!-- Main Script -->
  <script type="module">
    import 'p5';

    // === Simulation parameters and constants ===
    const CANVAS_WIDTH = 1200;
    const CANVAS_HEIGHT = 600;
    const GROUND_Y = CANVAS_HEIGHT * 0.85;
    const SOUND_SPEED = 343; // m/s
    const BASE_FREQUENCY = 440; // Hz
    const WAVE_SPEED_FACTOR = 0.5; // Visualization speed factor

    // UI elements
    let speedSlider, speedValueLabel;

    // Simulation state
    let aircraft;
    let observer;
    let soundWaves = [];
    let canvas;
    let simulationStopped = false;

    // For time-based wave emission
    let lastWaveEmitTime = 0;
    let waveEmitIntervalMs = 200;

    // Performance optimization
    let backgroundGraphics;
    let needsBackgroundUpdate = true;
    const MAX_WAVES = 80; // Limit number of waves for memory and performance

    // --- Aircraft class ---
    class Aircraft {
      constructor() {
        this.reset();
      }

      // Reset the aircraft state
      reset() {
        this.x = -100;
        this.y = GROUND_Y - 120;
        this.speed = 60;
        this.size = 60;
        this.trail = [];
      }

      // Advance aircraft
      update() {
        this.x += this.speed / 60;
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 25) this.trail.shift();
      }

      // Draw aircraft and its trail
      draw() {
        noFill();
        for (let i = 0; i < this.trail.length - 1; i++) {
          const alpha = map(i, 0, this.trail.length - 1, 20, 200);
          stroke(180, 180, 180, alpha);
          strokeWeight(map(i, 0, this.trail.length - 1, 1, 4));
          line(this.trail[i].x, this.trail[i].y, this.trail[i + 1].x, this.trail[i + 1].y);
        }
        push();
        translate(this.x, this.y);
        fill(240, 240, 240);
        noStroke();
        ellipse(0, 0, this.size * 1.2, this.size * 0.25);
        fill(220, 220, 220);
        triangle(this.size * 0.6, 0, this.size * 0.4, -this.size * 0.08, this.size * 0.4, this.size * 0.08);
        fill(200, 200, 200);
        ellipse(-this.size * 0.05, 0, this.size * 0.8, this.size * 0.12);
        fill(180, 180, 180);
        triangle(-this.size * 0.6, 0, -this.size * 0.4, -this.size * 0.15, -this.size * 0.4, this.size * 0.15);
        ellipse(-this.size * 0.5, -this.size * 0.08, this.size * 0.2, this.size * 0.06);
        fill(80, 120, 160);
        for (let i = 0; i < 5; i++) {
          ellipse(this.size * 0.3 - i * this.size * 0.08, -this.size * 0.04, this.size * 0.05, this.size * 0.05);
        }
        fill(120, 120, 120);
        ellipse(-this.size * 0.15, this.size * 0.12, this.size * 0.18, this.size * 0.06);
        ellipse(-this.size * 0.15, -this.size * 0.12, this.size * 0.18, this.size * 0.06);
        fill(60, 60, 60);
        ellipse(-this.size * 0.05, this.size * 0.12, this.size * 0.06, this.size * 0.04);
        ellipse(-this.size * 0.05, -this.size * 0.12, this.size * 0.06, this.size * 0.04);
        pop();

        // Aircraft speed label
        fill(255, 255, 255, 200);
        noStroke();
        rectMode(CENTER);
        rect(this.x, this.y + 45, 120, 20, 5);
        fill(0);
        textAlign(CENTER);
        textSize(12);
        text(`Speed: ${(this.speed * 3.6).toFixed(1)} km/h`, this.x, this.y + 50);
      }

      isOffScreen() {
        return this.x > CANVAS_WIDTH + 100;
      }
    }

    // --- Observer (listener) class ---
    class Observer {
      constructor() {
        this.x = CANVAS_WIDTH / 2;
        this.y = GROUND_Y;
        this.size = 45;
        this.currentFrequency = 0;
        this.waveHistory = [];
        this.maxFrequencyChangePerFrame = 6; // Lower for smoother freq transition
        this.hasPassed = false;
        this.maxFrequencyReached = BASE_FREQUENCY;
        this.passedTimestamp = 0;
      }

      draw() {
        push();
        translate(this.x, this.y);

        // Draw body, limbs, face - all as before
        fill(80, 120, 180); noStroke(); rectMode(CENTER); rect(0, 8, this.size * 0.5, this.size * 0.7, 5);
        fill(220, 180, 140); ellipse(-this.size * 0.35, 0, this.size * 0.15, this.size * 0.5); ellipse(this.size * 0.35, 0, this.size * 0.15, this.size * 0.5);
        fill(200, 160, 120); ellipse(-this.size * 0.35, this.size * 0.2, this.size * 0.1, this.size * 0.1); ellipse(this.size * 0.35, this.size * 0.2, this.size * 0.1, this.size * 0.1);
        fill(40, 40, 120); rect(-this.size * 0.12, this.size * 0.55, this.size * 0.15, this.size * 0.35, 3); rect(this.size * 0.12, this.size * 0.55, this.size * 0.15, this.size * 0.35, 3);
        fill(20, 20, 20); ellipse(-this.size * 0.12, this.size * 0.75, this.size * 0.2, this.size * 0.08); ellipse(this.size * 0.12, this.size * 0.75, this.size * 0.2, this.size * 0.08);
        fill(220, 180, 140); ellipse(0, -this.size * 0.25, this.size * 0.5, this.size * 0.5);
        fill(80, 40, 0); arc(0, -this.size * 0.35, this.size * 0.55, this.size * 0.3, PI, TWO_PI);
        fill(255); ellipse(-this.size * 0.08, -this.size * 0.28, this.size * 0.06, this.size * 0.06); ellipse(this.size * 0.08, -this.size * 0.28, this.size * 0.06, this.size * 0.06);
        fill(0, 100, 200); ellipse(-this.size * 0.08, -this.size * 0.28, this.size * 0.03, this.size * 0.03); ellipse(this.size * 0.08, -this.size * 0.28, this.size * 0.03, this.size * 0.03); fill(0);
        ellipse(-this.size * 0.08, -this.size * 0.28, this.size * 0.015, this.size * 0.015); ellipse(this.size * 0.08, -this.size * 0.28, this.size * 0.015, this.size * 0.015);
        stroke(60, 30, 0); strokeWeight(2); line(-this.size * 0.12, -this.size * 0.32, -this.size * 0.04, -this.size * 0.32); line(this.size * 0.04, -this.size * 0.32, this.size * 0.12, -this.size * 0.32);
        fill(200, 150, 120); noStroke(); ellipse(0, -this.size * 0.22, this.size * 0.02, this.size * 0.04);
        noFill(); stroke(150, 100, 80); strokeWeight(2); arc(0, -this.size * 0.15, this.size * 0.12, this.size * 0.08, 0, PI);
        pop();

        // Draw observer text label
        fill(255, 255, 255, 200); noStroke(); rectMode(CENTER); rect(this.x, this.y + this.size + 25, 80, 18, 5);
        fill(0); textAlign(CENTER); textSize(14); text("Observer", this.x, this.y + this.size + 30);
      }

      // Main Doppler effect & smoothing logic for frequency at observer
      updatePerceivedFrequency() {
        if (!aircraft) {
          this.currentFrequency = 0; return;
        }

        // Track passing of aircraft
        if (aircraft.x > this.x + 15 && !this.hasPassed) {
          this.hasPassed = true;
          this.passedTimestamp = millis();
          // Remove approaching waves once passed to avoid jitter
          this.waveHistory = this.waveHistory.filter(wave => !wave.isFromApproaching);
        }

        // Handle new sound waves reaching observer
        for (let i = soundWaves.length - 1; i >= 0; i--) {
          const wave = soundWaves[i];
          const distToObs = dist(wave.originX, wave.originY, this.x, this.y);
          if (wave.radius >= distToObs && !wave.hasReachedObserver) {
            wave.hasReachedObserver = true;
            const v = wave.aircraftSpeed;
            const c = SOUND_SPEED * WAVE_SPEED_FACTOR;
            const isApproaching = wave.originX <= this.x;
            const distFromObs = abs(wave.originX - this.x);
            let freq;
            if (isApproaching) {
              // Approaching Doppler
              const proximityFactor = constrain(map(distFromObs, 600, 0, 0.2, 1.0), 0.2, 1.0);
              const effectiveV = v * proximityFactor;
              freq = BASE_FREQUENCY * (c / (c - effectiveV));
              if (freq > this.maxFrequencyReached) this.maxFrequencyReached = freq;
            } else {
              // Receding: lower pitch
              const timeSincePass = millis() - this.passedTimestamp;
              const recedeFactor = constrain(map(distFromObs, 0, 600, 1.0, 0.2), 0.2, 1.0);
              const effectiveV = v * recedeFactor;
              freq = BASE_FREQUENCY * (c / (c + effectiveV));
              // Add extra frequency decay over time after pass
              const decayFactor = constrain(map(timeSincePass, 0, 2000, 1.0, 0.7), 0.7, 1.0);
              freq *= decayFactor;
            }
            // Blend frequency using distance for natural effect
            const distNorm = constrain(map(distFromObs, 0, 400, 1.0, 0.3), 0.3, 1.0);
            freq = lerp(BASE_FREQUENCY, freq, distNorm);
            freq = constrain(freq, BASE_FREQUENCY * 0.4, BASE_FREQUENCY * 1.8);
            this.waveHistory.push({ frequency: freq, timestamp: millis(), aircraftX: wave.originX, isFromApproaching: isApproaching });
          }
        }

        // Remove expired wave data
        const nowTime = millis();
        this.waveHistory = this.waveHistory.filter(wave => {
          const maxAge = wave.isFromApproaching ? 400 : 800;
          return nowTime - wave.timestamp < maxAge;
        });

        // Compute observer perceived (smoothed) frequency
        let targetFreq = 0;
        if (this.waveHistory.length > 0) {
          if (this.hasPassed) {
            // After passing, weight receding waves higher
            const recedingWaves = this.waveHistory.filter(wave => !wave.isFromApproaching);
            const approachingWaves = this.waveHistory.filter(wave => wave.isFromApproaching);
            let totalWeight = 0, weightedFreq = 0;
            for (let wave of recedingWaves) {
              const age = nowTime - wave.timestamp;
              const weight = Math.exp(-age / 400) * 3;
              totalWeight += weight; weightedFreq += wave.frequency * weight;
            }
            for (let wave of approachingWaves) {
              const age = nowTime - wave.timestamp;
              const weight = Math.exp(-age / 200) * 0.3;
              totalWeight += weight; weightedFreq += wave.frequency * weight;
            }
            targetFreq = totalWeight > 0 ? weightedFreq / totalWeight : 0;
          } else {
            // Approaching
            let totalWeight = 0, weightedFreq = 0;
            for (let wave of this.waveHistory) {
              const age = nowTime - wave.timestamp;
              const weight = Math.exp(-age / 300);
              totalWeight += weight; weightedFreq += wave.frequency * weight;
            }
            targetFreq = totalWeight > 0 ? weightedFreq / totalWeight : 0;
          }
        }

        // After passing, do not allow frequency to increase (for smoother drop)
        if (this.hasPassed && targetFreq > this.currentFrequency) {
          targetFreq = this.currentFrequency * 0.98;
        }

        // Smooth the frequency update (limits jitter)
        const freqDiff = targetFreq - this.currentFrequency;
        const maxChange = this.maxFrequencyChangePerFrame;
        if (abs(freqDiff) > maxChange) {
          this.currentFrequency += Math.sign(freqDiff) * maxChange;
        } else {
          const lerpRate = this.hasPassed ? 0.08 : 0.12;
          this.currentFrequency = lerp(this.currentFrequency, targetFreq, lerpRate);
        }
        // Fade out if no recent waves
        if (this.waveHistory.length === 0) {
          this.currentFrequency = lerp(this.currentFrequency, 0, 0.03);
        }
      }

      // Draw the frequency indicator panel
      drawFrequencyDisplay() {
        this.updatePerceivedFrequency();
        const freq = this.currentFrequency;
        fill(255, 250);
        stroke(0);
        strokeWeight(2);
        rectMode(CENTER);
        rect(this.x, this.y - 120, 220, 90, 12);
        fill(240, 240, 255, 100);
        rect(this.x, this.y - 120, 210, 80, 10);
        noStroke();
        fill(0);
        textAlign(CENTER, CENTER);
        textSize(28);
        textStyle(BOLD);
        text(`${freq.toFixed(1)} Hz`, this.x, this.y - 140);
        textSize(16);
        textStyle(NORMAL);
        const diff = freq - BASE_FREQUENCY;

        if (freq < 10) {
          fill(100, 100, 100);
          text("No Sound", this.x, this.y - 110);
          textSize(12);
          text("Waiting for waves...", this.x, this.y - 95);
        } else if (aircraft && aircraft.x >= this.x - 25 && aircraft.x <= this.x + 25 && !this.hasPassed) {
          fill(255, 165, 0);
          text("Overhead ↕", this.x, this.y - 110);
          textSize(12);
          fill(255, 140, 0);
          text(`${diff.toFixed(1)} Hz (Peak frequency)`, this.x, this.y - 95);
        } else if (aircraft && !this.hasPassed) {
          fill(255, 50, 50);
          text("Higher Pitch ↑", this.x, this.y - 110);
          textSize(12);
          fill(200, 0, 0);
          text(`+${diff.toFixed(1)} Hz (Approaching)`, this.x, this.y - 95);
        } else if (aircraft && this.hasPassed) {
          fill(50, 50, 255);
          text("Lower Pitch ↓", this.x, this.y - 110);
          textSize(12);
          fill(0, 0, 200);
          text(`${diff.toFixed(1)} Hz (Receding)`, this.x, this.y - 95);
        }
      }
    }

    // --- SoundWave class ---
    class SoundWave {
      constructor(x, y, birthTime, aircraftSpeed) {
        this.originX = x;
        this.originY = y;
        this.birthTime = birthTime;
        this.maxRadius = 800;
        this.aircraftSpeed = aircraftSpeed;
        this.radius = 0;
        this.hasReachedObserver = false;
      }

      // Update the expanding wave radius
      update() {
        const age = (millis() - this.birthTime) / 1000;
        this.radius = age * SOUND_SPEED * WAVE_SPEED_FACTOR;
      }

      // Draw the visual wavefront or Mach cone
      draw() {
        if (this.radius > this.maxRadius || this.radius < 5) return;
        const v = this.aircraftSpeed;
        const c = SOUND_SPEED * WAVE_SPEED_FACTOR;
        const mach = v / c;
        push();
        translate(this.originX, this.originY);
        let frontColor = color(255, 80, 80, 120);
        let backColor = color(80, 80, 255, 120);

        if (mach < 0.98) {
          stroke(lerpColor(frontColor, backColor, 0.5));
          strokeWeight(2.2);
          noFill();
          ellipse(0, 0, this.radius * 2, this.radius * 2);
        } else {
          let theta = Math.asin(1 / mach);
          stroke(backColor);
          strokeWeight(2.2);
          noFill();
          arc(0, 0, this.radius * 2, this.radius * 2, PI + theta, TWO_PI - theta);
          stroke(frontColor);
          strokeWeight(2.2);
          let coneLen = this.radius * 1.2;
          let x1 = Math.cos(theta) * coneLen;
          let y1 = -Math.sin(theta) * coneLen;
          let x2 = Math.cos(-theta) * coneLen;
          let y2 = -Math.sin(-theta) * coneLen;
          fill(255, 80, 80, 40);
          beginShape();
          vertex(0, 0);
          vertex(x1, y1);
          vertex(x2, y2);
          endShape(CLOSE);
          noFill();
          line(0, 0, x1, y1);
          line(0, 0, x2, y2);
        }
        pop();
      }

      isExpired() {
        return this.radius > this.maxRadius;
      }
    }

    // --- Cached background rendering for performance ---
    function createBackground() {
      if (!backgroundGraphics) {
        backgroundGraphics = createGraphics(CANVAS_WIDTH, CANVAS_HEIGHT);
      }
      backgroundGraphics.background(135, 206, 250);
      for (let i = 0; i <= GROUND_Y; i += 4) {
        const inter = map(i, 0, GROUND_Y, 0, 1);
        const c = lerpColor(color(135, 206, 250), color(220, 240, 255), inter);
        backgroundGraphics.stroke(c);
        backgroundGraphics.strokeWeight(4);
        backgroundGraphics.line(0, i, CANVAS_WIDTH, i);
      }
      backgroundGraphics.fill(34, 139, 34); backgroundGraphics.noStroke();
      backgroundGraphics.rect(0, GROUND_Y, CANVAS_WIDTH, CANVAS_HEIGHT - GROUND_Y);

      backgroundGraphics.fill(46, 125, 50);
      for (let x = 0; x < CANVAS_WIDTH; x += 40) {
        for (let y = GROUND_Y; y < CANVAS_HEIGHT; y += 20) {
          if (random() > 0.7) {
            backgroundGraphics.ellipse(x + random(-10, 10), y + random(-5, 5), random(3, 8), random(2, 5));
          }
        }
      }
      needsBackgroundUpdate = false;
    }

    // --- P5.js setup function: initialize simulation ---
    function setup() {
      canvas = createCanvas(CANVAS_WIDTH, CANVAS_HEIGHT);
      canvas.parent('canvas-container');
      aircraft = new Aircraft();
      observer = new Observer();
      speedSlider = document.getElementById('speedSlider');
      speedValueLabel = document.getElementById('speedValue');
      speedSlider.value = aircraft.speed;
      updateSpeedLabel(aircraft.speed);
      speedSlider.addEventListener('input', () => {
        aircraft.speed = parseFloat(speedSlider.value);
        updateSpeedLabel(aircraft.speed);
      });
      document.getElementById('resetBtn').addEventListener('click', resetSimulation);
      frameRate(60);
      simulationStopped = false;
      lastWaveEmitTime = millis();
      createBackground();
      loop();
    }

    // Update speed label under slider
    function updateSpeedLabel(speedPx) {
      speedValueLabel.textContent = (speedPx * 3.6).toFixed(1) + ' km/h';
    }

    // --- Main P5.js draw loop ---
    function draw() {
      if (simulationStopped) {
        fill(0);
        textAlign(CENTER, CENTER);
        textSize(36);
        text("Simulation Complete\nClick Reset to restart", CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
        noLoop();
        return;
      }
      // Only repaint static background if changed
      if (needsBackgroundUpdate) createBackground();
      image(backgroundGraphics, 0, 0);

      // Periodically emit a new sound wave
      let now = millis();
      if (now - lastWaveEmitTime > waveEmitIntervalMs) {
        soundWaves.push(new SoundWave(aircraft.x, aircraft.y, now, aircraft.speed));
        lastWaveEmitTime = now;
      }

      // Efficient batch removal and update of sound waves
      let writeIndex = 0;
      for (let readIndex = 0; readIndex < soundWaves.length; readIndex++) {
        const wave = soundWaves[readIndex];
        wave.update();
        if (!wave.isExpired()) {
          soundWaves[writeIndex++] = wave;
          wave.draw();
        }
      }
      soundWaves.length = writeIndex;
      if (soundWaves.length > MAX_WAVES) {
        soundWaves.splice(0, soundWaves.length - MAX_WAVES);
      }

      // Advance aircraft and observer
      if (aircraft) {
        aircraft.update();
        aircraft.draw();
        if (aircraft.isOffScreen()) simulationStopped = true;
      }

      observer.draw();
      observer.drawFrequencyDisplay();

      // UI overlay
      noStroke();
      rect(5, 40, CANVAS_WIDTH - 10, 80, 8);
      fill(255);
      textAlign(LEFT);
      textSize(16);
      textStyle(BOLD);
      text("Fixed Doppler Effect Simulation", 15, 25);
      textStyle(NORMAL);
      textSize(13);
      text("• Frequency increases as aircraft approaches, decreases smoothly after passing", 15, 45);
      text("• Realistic Doppler effect without frequency oscillation", 15, 62);
    }

    // --- Reset simulation to initial state ---
    function resetSimulation() {
      if (aircraft) aircraft.reset();
      soundWaves = [];
      if (observer) {
        observer.currentFrequency = 0;
        observer.waveHistory = [];
        observer.lastFrameFrequency = 0;
        observer.hasPassed = false;
        observer.maxFrequencyReached = BASE_FREQUENCY;
        observer.passedTimestamp = 0;
      }
      speedSlider.value = aircraft.speed;
      updateSpeedLabel(aircraft.speed);
      simulationStopped = false;
      lastWaveEmitTime = millis();
      needsBackgroundUpdate = true;
      loop();
    }

    // Expose setup and draw for P5.js
    window.setup = setup;
    window.draw = draw;
  </script>
</body>
</html>
